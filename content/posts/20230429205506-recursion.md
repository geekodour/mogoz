+++
title = "Recursion"
author = ["Hrishikesh Barman"]
draft = false
+++

tags
: [Math]({{< relref "20221101134840-math.md" >}}), [Programming Languages]({{< relref "20221101220306-programming_languages.md" >}}), [Automata Theory]({{< relref "20230421132238-automata_theory.md" >}})


## FAQ {#faq}


### Recursive procedure vs Recursive process {#recursive-procedure-vs-recursive-process}

<div class="warning small-text">

> Knowing the `procedures` and not knowing the `process` is similar to someone who has learned the rules for how the pieces move in chess but knows nothing of typical openings, tactics, or strategy. - [1.2](https://sarabander.github.io/sicp/html/1_002e2.xhtml#g_t1_002e2_002e1)
</div>


#### Procedure {#procedure}

-   A procedure is a pattern for the local evolution of a computational process.


#### Process {#process}

-   Recursive: Needs to maintain the state of the caller while the recursive call is in progress.
-   Iterative: The earlier state can be discarded.


#### Why does this distinction matter? {#why-does-this-distinction-matter}

-   This is commonly used in functional programming, a recursive procedure is used [to do a iterative process](https://stackoverflow.com/questions/17254240/sicp-recursive-process-vs-iterative-process-using-a-recursive-procedure-to-gene) in the absence of loops in the language.
-   This came to my mind when I thought of implementing [BFS recursively]({{< relref "20230205172402-algorithms.md" >}}). This is like trying to draw a square circle. It's not a recursive process and yet I wanted to do it recursively, I could probably do it but at the end it'll probably just the procedure that'll be recursive and not the process by the nature of the problem.


### Stack contains Frames {#stack-contains-frames}

-   Stack
    -   Stack aka call stack. Stack grows downwards. Stack contains frames.
-   Frame
    -   Frame aka Stack frame.
    -   Frame = function arguments + local data + return address
    -   Each call to a function creates a new frame and pushes it into the stack


### JMP vs CALL {#jmp-vs-call}

These are assembly instructions but do not directly related to recursion/tail recursion but good to keep in mind.

-   `JMP` : A transfer of the control to another location and the control does not automatically return to the point from where it is called.
-   `CALL` CALL pushes the current instruction pointer on the stack and then then JMPs to the location


### Recursion and the Stack {#recursion-and-the-stack}

-   Generally, [programming Languages]({{< relref "20221101220306-programming_languages.md" >}}) use the [call stack]({{< relref "20221101213015-garbage_collection.md" >}}) to implement recursion.
-   So if you do \\(n!\\) of a large number, there's solid chances you'll blow off the stack.
-   But if get to program in a language that supports `tail recursion` (essentially iteration), usually you'll get infinite recursion without a stack overflow :)
-   See [Recursive tail calls]({{< relref "20230520194955-tail_calls.md#recursive-tail-calls" >}})


## What? {#what}

-   Function that calls itself until the problem is solved.
-   Involves what is referred to as a "base case.”
    -   A base case is the point in which the problem is solved at.


### Factorial example {#factorial-example}

```text
foo(n):
    if n = 1:
       return 1 // base case
    return n*foo(n-1) // inductive case
```

{{< figure src="/ox-hugo/20230429205506-recursion-1908342536.png" >}}


### When to use? {#when-to-use}

-   When it's too difficult/cumbersome to do iteratively
-   When there's high degree of [branching factor](https://en.wikipedia.org/wiki/Branching_factor)


## Parts {#parts}

This base and inductive cases are more for understanding, when implementing things usually get mixed more or less.


### Base case {#base-case}

-   Solve the simplest cases in the base case
-   The base case does not have to be just one single condition. It can be multiple conditions.
-   Preferably move checks and validation sort of things to the base case. But this is **not** a rule.


### Inductive case {#inductive-case}

-   Sub parts (all may not be at use)
    -   **pre-operation** : Before you recurse
    -   **recurse** : Where you recurse
    -   **post-operation** : After you recurse but before the final return. (i.e there can be early returns elsewhere)
-   Notes on subparts
    -   **post-operation**
        -   This is useful when we want to recurse but also do some comparison of sorts on the result. Eg. find max in a list


## Types {#types}


### Structural {#structural}


### Generative {#generative}


### Mutual {#mutual}

-   Two function calling each other


## Tips from the internet {#tips-from-the-internet}

-   stop trying to imagine the flow, you’ll just get lost and more confused.
    -   Instead, start with your inductive case
        -   If someone handed you the answer to a smaller problem, how would you get the answer to your problem?
    -   Once you’ve figured that out, switch to the base case
        -   What are the smallest problems that you can solve immediately?
    -   Put the two together and you’re probably 95% of the way there.
-   Understand
    -   The difference between structural and generative recursion
    -   The relationship between structural recursion and induction
        -   Every structurally recursive function is a mirror of an inductive definition.
-   The biggest mistake one can make is writing a recursive function without thinking about the inductively defined data it works on.
