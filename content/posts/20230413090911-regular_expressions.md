+++
title = "Regular Expressions"
author = ["Hrishikesh Barman"]
draft = false
+++

tags
: [Programming Languages]({{< relref "20221101220306-programming_languages.md" >}}), [Computation and Computer Theory]({{< relref "20221101221439-computation_and_computer_theory.md" >}}), [Automata Theory]({{< relref "20230421132238-automata_theory.md" >}})


## History {#history}

We get 2 definitions of `regular languages` from these 2 events.

-   1951, Kleene: Regular language is a language which is recognized by a finite automata.
-   1956, Chomsky: Regular languages defined by languages generated by `Type 3` / `regular grammars`


## Theory {#theory}

-   RE describes language by an algebra
-   They describe "exactly" the regular language
-   `L(E)` is the `language`, `E` is the regex.


### Operations {#operations}


#### Union {#union}

-   Eg. `{01,111,10} \cup {00, 01}` = `{01,111,10,00}`


#### Concatenation {#concatenation}

-   Eg. `{01,111,10}{00, 01}` = `{0100, 0101, 11100, 11101, 1000, 1001}`


#### Kleene Star {#kleene-star}

-   `A*` : Kleene closure / Kleene star
-   L\* = `{\epsilon} \cup L \cup LL \cup LLL \cup ...`
-   Eg. {0,10}\* = {&epsilon;, 0, 10, 00, 010, 100, 1010,...}


## Lexical Analysis {#lexical-analysis}

> -   `tokens`: substrings that together represent a unit.


### Basics {#basics}

-   The first thing a compiler does is break a program into `tokens`
-   We can write `regex` for each different kind of `token`
-   Each `regex` has a specific action associated
    -   Eg. Just print out, put it into a symbol table etc.


### Issues {#issues}

{{< figure src="/ox-hugo/20230413090911-regular_expressions-1559352848.png" >}}

1.  Convert `RE` for each `token` to &epsilon;-NFA
    -   Eg. identifier &epsilon;-NFA
    -   Eg. Reserved word &epsilon;-NFA
2.  Combine all `RE` by w new start state w &epsilon; moves to start state of each &epsilon;-NFA
3.  Convert to DFA
4.  Set priority in DFA. Eg. DFA accepting `if` reserved word should have higher priority than DFA accepting identifier `if`


## Implementations {#implementations}


### Modern Implementations {#modern-implementations}

-   Modern regex engines are augmented with features that allow the recognition of non-regular languages
-   Characters like, `[` and `-` have special meanings, so you need to escape them with `\`
-   Some operators
    -   Concatenation: [a<sub>1</sub>,a<sub>2</sub>,...a<sub>n</sub>] is shorthand for a<sub>1</sub>+a<sub>2</sub>+...+a<sub>n</sub>
    -   Union: | operator.
    -   One or more: `+` , `E+` = `EE*` (E concatenated w E\*)
    -   Zero or one of: `?`, E? = E + &epsilon;, `[ab]?` = a + b + &epsilon;


### Flavors {#flavors}

-   PCRE
