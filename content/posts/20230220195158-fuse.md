+++
title = "Fuse"
author = ["Hrishikesh Barman"]
draft = false
+++

tags
: [Filesystems]({{< relref "20221101145053-filesystems.md" >}})


## Filesystems Primer {#filesystems-primer}


### What they do {#what-they-do}

-   Mapping
    -   They provide a `filename-to-anything mapping`. Anything can be your HDD, some git repository(gitfs) or some computer connected through ssh etc(sshfs).
    -   What filesystems essentially do is that they `map a filename` you see to the `actual position where the data is saved`.
-   Structure and Organization
    -   Determining the structure how the data is really saved
    -   It tells what structure it wants the data to be written to the actual hardware driver(sata driver in most PCs nowadays).
    -   Eg. one filesystem for example could say it writes files at the next empty space it can find (eg. ntfs)
    -   Eg. another filesystem writes files in the middle of an empty block (eg. ext4)
-   Metadata
    -   Metadata is saved alongside with the filedata. (Creation date, permissions etc.)


### What they don't do {#what-they-don-t-do}

-   They don't write directly to a harddisk.


### Series of events {#series-of-events}

<div class="warning small-text">

> This is extremely simplified version. Lots of details missing. Eg. when accessing metadata we already need to be communicating with the hardware driver.
</div>

1.  Program uses the system call `open` to open a file and gives it a path and filename (eg. `"/home/geekodour/readme.txt`)
2.  Kernel uses `/home/geekodour` to determine what filesystem and hardware device is needed.
    -   Each directory in a linux filesystem could be mounted to a different filesystem (and/or on a different hardware device)
    -   With the path the kernel can say what filesystem is needed in this case.
3.  Kernel tells the filesystem driver (`kernel module` or `fuse`, doesn't matter) that this file is requested
4.  Filesystem driver gathers all the data needed to access the real data on the harddisk from the filename
    -   Also checks if access is even possible (Eg. if the metadata of this file allow the user to even read it)
5.  Gathered data is then handed to the `hardware driver` responsible for the `device` which then gets the real data that can be handed back to the application.


## Intro {#intro}

-   Traditionally filesystems were created as kernel drivers/modules. And as we said..the kernel runs in ring 0 with full access.
-   Fuse is a kernel layer that allows the kernel to use filesystem implementions written in userpace. In other words, allows the kernel to redirect filesystem calls to a userspace (ring 3) implementation.
-   You can write your whole filesystem as userspace application, register it with the kernel and if a program tries to open a file from your filesystem the kernel asks your implementation to do it.
-   Pro
    -   We gain security and make creating filesystems a lot easier.
-   Con:
    -   Speed. But if making a network file system, we cannot care less, right?
    -   Fuse filesystems can do much less than filesystems that are kernel modules.
    -   You cannot do stuff like send commands over the SATA bus to communicate with the HDD directly. FS which are kernel modules are capable of this.


## Resources {#resources}

-   <https://www.reddit.com/r/linux4noobs/comments/7fm0hi/eli5_what_is_fuse/>
-   Random Fun Fuse FS(s)
    -   <https://github.com/koding/awesome-fuse-fs>
    -   <https://github.com/ImJasonH/ghfs>
    -   <https://github.com/yarrick/pingfs/>
    -   [Database as Filesystem - YouTube](https://www.youtube.com/watch?v=wN6IwNriwHc)
    -   <https://github.com/ufrisk/MemProcFS>
    -   <https://en.wikipedia.org/wiki/WikipediaFS>
    -   <https://github.com/rasguanabana/ytfs>
    -   <https://github.com/oniony/TMSU>
    -   <https://github.com/unbit/spockfs>
    -   <https://github.com/ianpreston/redditfs>
    -   <https://github.com/hausdorff/snapchat-fs>
-   Extra FS tools
    -   <https://eaglemode.sourceforge.net/>
    -   <https://github.com/mcuelenaere/fsv>
