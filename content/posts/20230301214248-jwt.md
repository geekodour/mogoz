+++
title = "JWT"
author = ["Hrishikesh Barman"]
draft = false
+++

tags
: [OAuth (Open Authorization)]({{< relref "20230301205620-authorization.md#oauth--open-authorization" >}})


## FAQ {#faq}


### History {#history}

-   First draft in 2012
-   Final draft in 2015 : <https://datatracker.ietf.org/doc/html/rfc7519>


### What JWT does differently than [Web Sessions]({{< relref "20231102113142-web_sessions.md" >}})? {#what-jwt-does-differently-than-web-sessions--20231102113142-web-sessions-dot-md}

-   Instead of an `opaque token` in a [Cookie]({{< relref "20230615111924-cookies.md" >}}), we actually embed the `user_id` itself but `signed`.
-   The `signature` can only be generated by the server which has access to a `secret`
    -   `signature` = `secret + payload + header`
-   When we send the JWT, we send the `signature + payload + header`. This way, if any of `payload` or `header` is tampered, `signature` won't match.
-   The usecase is somewhat different too, think `stateless` v/s `stateful`
-   More importantly, [Web Sessions]({{< relref "20231102113142-web_sessions.md" >}}) are very tightly knit with [Cookies]({{< relref "20230615111924-cookies.md" >}}), whereas JWTs are not. While it's a safe practice to store JWT in [Cookies]({{< relref "20230615111924-cookies.md" >}}), it doesn't have to be that always, depending on usecase, client can store JWT in memory, session-storage, others etc.


### Example of a scene where JWT useful (Need to verify :)) {#example-of-a-scene-where-jwt-useful--need-to-verify}

-   I made this up, idk if makes sense or is correct
-   S:Server,C:Client,R:Resource
-   `S` wants to give `C` access to `R`
-   `R` does not trust `C`. `R` trust `S`.
-   `S` will sign a token(jwt) and send it to `C`, `C` then use it to access `R`.
-   `R` will comply because, it sees that oh, this is approved by `S`
-   Usually the `token(jwt)` is stored in a [Cookie]({{< relref "20230615111924-cookies.md" >}}) and with settings that allows it to be passed to `R`. But in certain cases, `token(jwt)` might be stored elsewhere and our application logic can make use of it.


## What {#what}

{{< figure src="/ox-hugo/20230301214248-jwt-1998567805.png" >}}

-   JWT is a format of a token.
-   Signed but non-opaque, [Web Sessions]({{< relref "20231102113142-web_sessions.md" >}}) are opaque tokens
-   Defines a container to transport data between interested parties.
-   JWT is independent of [OAuth (Open Authorization)]({{< relref "20230301205620-authorization.md#oauth--open-authorization" >}}) and [OIDC (OpenID Connect)]({{< relref "20230301191046-authentication.md#oidc--openid-connect" >}})


## Concerns {#concerns}

Lot of [blogposts](https://paragonie.com/blog/2017/03/jwt-json-web-tokens-is-bad-standard-that-everyone-should-avoid) on the internet [bashing](http://cryto.net/%7Ejoepie91/blog/2016/06/13/stop-using-jwt-for-sessions/) JWT, this is mostly about how often JWT gets misused and not flaw of JWTs itself. The following is just summary from the [famous owasp cheetsheet.](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html#token-sidejacking)


### Logging out {#logging-out}

-   This was what was mention in using JWT for stateful stuff. (Not recommended)
-   If you really want to do it, here's an idea from someone: "My favourite solution to this is keep a global list of JWTs that have been revoked before they expired (and remove the tokens after expiry). Instead of letting webservers hit a server to get this list, push the list to each server using a pub/sub mechanism."


### None hashing {#none-hashing}

-   Some JWT libs consider tokens signed with `none` as valid. (BAD)
-   Sol
    -   Just use a proper JWT lib
    -   VAlidate the algorithm is what we expected it to be server side per req.


### Token Sidejacking {#token-sidejacking}

Token got stolen, impersonation.

The idea is to basically add an `user context` (Basically something that the only original user can have). i.e Even if they're able to steal the JWT token somehow, they won't be able to steal the `user context` token from the hardened cookie.

tbh, this seems like reimplementation of [Web Sessions]({{< relref "20231102113142-web_sessions.md" >}}) to me, We cannot revoke stuff like in `sessions` but with this we can sorta validate but this becomes more prominent when you think that JWT's are not always meant to be stored in [Cookies]({{< relref "20230615111924-cookies.md" >}}), in that sense a hardened `user context` cookie can provide protection against [XSS]({{< relref "20230616121539-xss.md" >}}) and hence prevent stealing as described below.

-   We can use IP address for the `user-context`, but that's not a great idea because it can change
-   Turns out, `a random string+strict cookie` is good enough. Let's called it the `Secure Fingerprint (Secure-Fpg)` cookie. This `Secure-Fpg` is our `user context`


#### Client side {#client-side}

-   Generate a random string(SHA256), put the raw value of this string into a Hardened [Cookie]({{< relref "20230615111924-cookies.md" >}})
    -   Additionally, for the hardened cookie set
        -   `Expires` = `None`, so that cookie is cleared when the browser is closed.
        -   `Max-Age` &lt;= value of JWT token expiry (never more)
    -   This becomes out `Secure-Fpg`. i.e `user context` = `Secure-Fpg` = `raw random string+cookie`
-   In the actual JWT token, add a `hash` of the `raw random string`. We can send the JWT token as a [Cookie]({{< relref "20230615111924-cookies.md" >}}) or however we desire.


#### Server side {#server-side}

-   On the server side, we keep track of `Secure-Fpg` that we send. (Similar to [Web Sessions]({{< relref "20231102113142-web_sessions.md" >}}))
-   On validation, we check the `user context` cookie against saved `user contexts`
-   Then we again calculate the hash for the `raw random string`
-   Then we verify the hash against the hash in the JWT token.


### Token Information Disclosure {#token-information-disclosure}

-   JWT token data is base64 encoded but not encrypted
-   We can use symmetric encryption if we want to here


### Weak Token Secret {#weak-token-secret}

-   If using weak secret for HMAC
-   Attacker can take the JWT and then run an offline attack on it
-   This will allow them to resign tokens


## Usecases {#usecases}


### Stateful application {#stateful-application}

-   See [Cookies]({{< relref "20230615111924-cookies.md" >}}) and [Web Authentication]({{< relref "20221109172102-web_authentication.md" >}})
-   Use of JWTs for `stateful session management` is 99% of the time **BAD**, because JWT are designed to be stateless.
-   JWT is used by an application to allow a client to present a token representing the user's "identity card" to the server and allow the server to verify the validity and integrity of the token in a secure way. (All this happens in a stateless way)
-   Individual stateless JWT tokens cannot be invalidated.
-   If you need (logout/access revocation etc), stateless would not work, you'll need server side state. Just deleting the secure http-only cookie will just delete the token but not really invalidate it.
-   You can use client side logic to enforce this or maybe change the jwt secret on the server!
-   At this point you might as well use traditional stateful opaque sessions


### Stateless application {#stateless-application}

-   Short term authorization tokens
    -   Great for short term authentication between decentralized systems. Eg. 5 minute expiration between a web api and a websocket service.
    -   JWTs are good for API tokens
    -   [Web Sessions]({{< relref "20231102113142-web_sessions.md" >}}) on frontend, JWT on backend for service to service communication.
-   JWT, when implemented well in stateless application can be a good candidate
-   Handy in a distributed system or inside a trusted environment also. User-actions may cause requests to several http-endpoints([Microservices]({{< relref "20230210012034-microservices.md" >}})) that all have to somehow individually verify the authentication. In this case JWT can help not needed all these to have access to the [Web Sessions]({{< relref "20231102113142-web_sessions.md" >}}) data store, this become simple as the token will be signed by a trusted entity that the different services trust and they just need to have it's public key(See [PKI]({{< relref "20230417085602-pki.md" >}})).
-   See [Ways to do it](#ways-to-do-it) section
-   Another example of stateless session using encrypted cookies: [vvo/iron-session](https://github.com/vvo/iron-session)


## Ways to do it {#ways-to-do-it}


### Auth {#auth}

Use of [JWT]({{< relref "20230301214248-jwt.md" >}}) for Auth means using JWT for stateful stuff mostly which i am not super convinced of


#### Send it via [Cookies]({{< relref "20230615111924-cookies.md" >}}) {#send-it-via-cookies--20230615111924-cookies-dot-md}

-   Cookie Hardening
-   Backend w proper [CORS]({{< relref "20230302210256-cors.md" >}}) policy


#### Send it via [HTTP]({{< relref "20230222161545-http.md" >}}) Bearer token with [TLS]({{< relref "20230210181907-tls.md" >}}) {#send-it-via-http--20230222161545-http-dot-md--bearer-token-with-tls--20230210181907-tls-dot-md}

-   This is what applications which are not Browsers do afaik
-   Can be vulnerable to [XSS]({{< relref "20230616121539-xss.md" >}})


### Info exchange/delegation of access {#info-exchange-delegation-of-access}


#### Sent it in API response and let client decide {#sent-it-in-api-response-and-let-client-decide}

-   Since the token is signed, we can just send it.
-   The client can decide how they want to use it, this is more useful in the [usecase of "Information Exchange"](https://jwt.io/introduction) compared to [Authentication]({{< relref "20230301191046-authentication.md" >}}).


### Use on [OIDC (OpenID Connect)]({{< relref "20230301191046-authentication.md#oidc--openid-connect" >}}) {#use-on-oidc--openid-connect----20230301191046-authentication-dot-md}

-   OIDC does not mandate the use of JWT as the `ID token` (JAR) / `access token`
    -   In fact there's no structure defined for the token, but using JWT has benefits.
    -   But OIDC tokens are transparent unlike OAuth(opaque tokens), So JWT fits!
-   Allows other flows (hybrid or implicit) to be used.
-   Good library support
-   Can hold payload
-   Signed token, so the RP can still trust it even though it's been received via an untrusted channel.
