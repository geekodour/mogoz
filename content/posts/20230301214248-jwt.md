+++
title = "JWT"
author = ["Hrishikesh Barman"]
draft = false
+++

tags
: [OAuth (Open Authorization)]({{< relref "20230301205620-authorization.md#oauth--open-authorization" >}})


## FAQ {#faq}


### History {#history}

-   First draft in 2012
-   Final draft in 2015 : <https://datatracker.ietf.org/doc/html/rfc7519>


### What JWT does differently than [Web Sessions]({{< relref "20231102113142-web_sessions.md" >}})? {#what-jwt-does-differently-than-web-sessions--20231102113142-web-sessions-dot-md}

-   Instead of an `opaque token` in a [Cookie]({{< relref "20230615111924-cookies.md" >}}), we actually embed the `user_id` itself but `signed`.
-   The `signature` can only be generated by the server which has access to a `secret`
    -   `signature` = `secret + payload + header`
-   When we send the JWT, we send the `signature + payload + header`. This way, if any of `payload` or `header` is tampered, `signature` won't match.
-   The usecase is somewhat different too, think `stateless` v/s `stateful`
-   More importantly, [Web Sessions]({{< relref "20231102113142-web_sessions.md" >}}) are very tightly knit with [Cookies]({{< relref "20230615111924-cookies.md" >}}), whereas JWTs are not. While it's a safe practice to store JWT in [Cookies]({{< relref "20230615111924-cookies.md" >}}), it doesn't have to be that always, depending on usecase, client can store JWT in memory, session-storage, others etc.


### Example of a scene where JWT useful (Need to verify :)) {#example-of-a-scene-where-jwt-useful--need-to-verify}

-   I made this up, idk if makes sense or is correct
-   S:Server,C:Client,R:Resource
-   `S` wants to give `C` access to `R`
-   `R` does not trust `C`. `R` trust `S`.
-   `S` will sign a token(jwt) and send it to `C`, `C` then use it to access `R`.
-   `R` will comply because, it sees that oh, this is approved by `S`
-   Usually the `token(jwt)` is stored in a [Cookie]({{< relref "20230615111924-cookies.md" >}}) and with settings that allows it to be passed to `R`. But in certain cases, `token(jwt)` might be stored elsewhere and our application logic can make use of it.


### S1 and S3 don't trust each other but both trust S2, but how does S2 trust S1&amp;s3 are legit servers asking for JWT {#s1-and-s3-don-t-trust-each-other-but-both-trust-s2-but-how-does-s2-trust-s1-and-s3-are-legit-servers-asking-for-jwt}

I am not 100% sure of this answer but guess this is where pre-shared keys/ [mTLS]({{< relref "20230210181907-tls.md#mtls" >}}) comes in


### JWKS {#jwks}


#### JWK vs JWKS {#jwk-vs-jwks}

| What                    | Desciption                                                                                                                         |
|-------------------------|------------------------------------------------------------------------------------------------------------------------------------|
| JSON Web Key (JWK)      | A JSON object that represents a cryptographic key. The members of the object represent properties of the key, including its value. |
| JSON Web Key Set (JWKS) | A JSON object that represents a set of JWKs. The JSON object MUST have a keys member, which is an array of JWKs.                   |


#### What? {#what}

-   <https://datatracker.ietf.org/doc/html/rfc7517>
-   They keys used for doing JWT stuff
-   The values of the JWK Container Object members can change depending on which algorithm is used.
-   Eg. JWK container using RSA algorithm and has the following members: `alg, mod, exp, kid`. Some other agl will have other members etc.


#### How to obtain? {#how-to-obtain}

-   Typically the JWKS can be retrieved by querying an "endpoint" exposed by the Authorization Server known as a `jwks endpoint`
    -   Eg. `Auth0` exposes a JWKS endpoint for `each tenant`, which is found at `https://{yourDomain}/.well-known/jwks.json` (i.e a private key each tenant)
-   There are ways to mock the endpoint: <https://github.com/murar8/local-jwks-server>
-   What about generate?????
    -   not for prod?
    -   <https://github.com/MicahParks/jwkset>
    -   <https://www.ory.sh/docs/cli/ory-create-jwk>
    -   <https://mkjwk.org/>
    -   <https://jwkset.com/generate>


### Signed or Encrypted? {#signed-or-encrypted}

-   [cookies - Is it necessary to encrypt a JSON Web Token more than what is built-in? - Information Security Stack Exchange](https://security.stackexchange.com/questions/236531/is-it-necessary-to-encrypt-a-json-web-token-more-than-what-is-built-in)

    > JWT can be:
    >
    > -   signed (JWS - RFC7515)
    > -   encrypted (JWE - RFC7516)
    > -   signed then encrypted (the whole JWS is the payload of the JWE)
    > -   encrypted then signed (the whole JWE is the payload of the JWS)


### Verification {#verification}


#### Signature verification {#signature-verification}

-   Just make sure you have the correct signature


#### <span class="org-todo todo TODO">TODO</span> Expire of the token {#expire-of-the-token}


## What {#what}

{{< figure src="/ox-hugo/20230301214248-jwt-1998567805.png" >}}

-   JWT is a format of a token.
-   Signed but non-opaque, [Web Sessions]({{< relref "20231102113142-web_sessions.md" >}}) are opaque tokens
-   Defines a container to transport data between interested parties.
-   JWT is independent of [OAuth (Open Authorization)]({{< relref "20230301205620-authorization.md#oauth--open-authorization" >}}) and [OIDC (OpenID Connect)]({{< relref "20230301191046-authentication.md#oidc--openid-connect" >}})


## Algorithms for JWT {#algorithms-for-jwt}


### Process {#process}

-   First you generate the `.pem` file. Either symmetric/asymmetric
-   Then you use a pem to jwk/jwks converter thingy
-   Then your application uses jwk to create the token
-   Later other application can verify if it's the correct token by using the symmetric/asymmetric key.


### Types {#types}

> Both of these types work in jwt.io, but confusingly it also asks for private key in the ui
>
> -   [Why do I need a private key to verify a JWT? - #4 by tyf - Auth0 Community](https://community.auth0.com/t/why-do-i-need-a-private-key-to-verify-a-jwt/129774/4)
>
> But as mentioned, it'd work even if you just give the public key for verification. (which is the case for asymmetric keys)
>
> Also, you can use the content of jwks.json file X.509/PKCS/PKIX private key .pem files to supply the public/private keys, but just giving the jwks.json is much simpler is what I prefer.


#### Symmetric {#symmetric}

-   [HMAC]({{< relref "20231215104223-hmac.md" >}}) based


#### Asymmetric Algorithms {#asymmetric-algorithms}

-   generate using the private key
-   verify using the public key
-   Eg. RSA and ECDSA signatures
-   When generating the `jwks` for this, you'll get
    -   Public and Private Keypair Set
    -   Public Key
    -   Private Key
    -   All of them will be json, `Public Key` will have most of `Private Key` with some fields missing, eg with es256 `d` will be miising. i.e `d` is a private component.


## Concerns {#concerns}

Lot of [blogposts](https://paragonie.com/blog/2017/03/jwt-json-web-tokens-is-bad-standard-that-everyone-should-avoid) on the internet [bashing](http://cryto.net/%7Ejoepie91/blog/2016/06/13/stop-using-jwt-for-sessions/) JWT, this is mostly about how often JWT gets misused and not flaw of JWTs itself. The following is just summary from the [famous owasp cheetsheet.](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html#token-sidejacking)


### Logging out {#logging-out}

-   This was what was mention in using JWT for stateful stuff. (Not recommended)
-   If you really want to do it, here's an idea from someone: "My favourite solution to this is keep a global list of JWTs that have been revoked before they expired (and remove the tokens after expiry). Instead of letting webservers hit a server to get this list, push the list to each server using a pub/sub mechanism."


### None hashing {#none-hashing}

-   Some JWT libs consider tokens signed with `none` as valid. (BAD)
-   Sol
    -   Just use a proper JWT lib
    -   VAlidate the algorithm is what we expected it to be server side per req.


### Token Sidejacking {#token-sidejacking}

Token got stolen, impersonation.

The idea is to basically add an `user context` (Basically something that the only original user can have). i.e Even if they're able to steal the JWT token somehow, they won't be able to steal the `user context` token from the hardened cookie.

tbh, this seems like reimplementation of [Web Sessions]({{< relref "20231102113142-web_sessions.md" >}}) to me, We cannot revoke stuff like in `sessions` but with this we can sorta validate but this becomes more prominent when you think that JWT's are not always meant to be stored in [Cookies]({{< relref "20230615111924-cookies.md" >}}), in that sense a hardened `user context` cookie can provide protection against [XSS]({{< relref "20230616121539-xss.md" >}}) and hence prevent stealing as described below.

-   We can use IP address for the `user-context`, but that's not a great idea because it can change
-   Turns out, `a random string+strict cookie` is good enough. Let's called it the `Secure Fingerprint (Secure-Fpg)` cookie. This `Secure-Fpg` is our `user context`


#### Client side {#client-side}

-   Generate a random string(SHA256), put the raw value of this string into a Hardened [Cookie]({{< relref "20230615111924-cookies.md" >}})
    -   Additionally, for the hardened cookie set
        -   `Expires` = `None`, so that cookie is cleared when the browser is closed.
        -   `Max-Age` &lt;= value of JWT token expiry (never more)
    -   This becomes out `Secure-Fpg`. i.e `user context` = `Secure-Fpg` = `raw random string+cookie`
-   In the actual JWT token, add a `hash` of the `raw random string`. We can send the JWT token as a [Cookie]({{< relref "20230615111924-cookies.md" >}}) or however we desire.


#### Server side {#server-side}

-   On the server side, we keep track of `Secure-Fpg` that we send. (Similar to [Web Sessions]({{< relref "20231102113142-web_sessions.md" >}}))
-   On validation, we check the `user context` cookie against saved `user contexts`
-   Then we again calculate the hash for the `raw random string`
-   Then we verify the hash against the hash in the JWT token.


### Token Information Disclosure {#token-information-disclosure}

-   JWT token data is base64 encoded but not encrypted
-   We can use symmetric encryption if we want to here


### Weak Token Secret {#weak-token-secret}

-   If using weak secret for HMAC
-   Attacker can take the JWT and then run an offline attack on it
-   This will allow them to resign tokens


## Usecases {#usecases}


### Stateful application {#stateful-application}

-   See [Cookies]({{< relref "20230615111924-cookies.md" >}}) and [Web Authentication]({{< relref "20221109172102-web_authentication.md" >}})
-   Use of JWTs for `stateful session management` is 99% of the time **BAD**, because JWT are designed to be stateless.
-   JWT is used by an application to allow a client to present a token representing the user's "identity card" to the server and allow the server to verify the validity and integrity of the token in a secure way. (All this happens in a stateless way)
-   Individual stateless JWT tokens cannot be invalidated.
-   If you need (logout/access revocation etc), stateless would not work, you'll need server side state. Just deleting the secure http-only cookie will just delete the token but not really invalidate it.
-   You can use client side logic to enforce this or maybe change the jwt secret on the server!
-   At this point you might as well use traditional stateful opaque sessions


### Stateless application {#stateless-application}

-   Short term authorization tokens
    -   Great for short term authentication between decentralized systems. Eg. 5 minute expiration between a web api and a websocket service.
    -   JWTs are good for API tokens
    -   [Web Sessions]({{< relref "20231102113142-web_sessions.md" >}}) on frontend, JWT on backend for service to service communication.
-   JWT, when implemented well in stateless application can be a good candidate
-   Handy in a distributed system or inside a trusted environment also. User-actions may cause requests to several http-endpoints([Microservices]({{< relref "20230210012034-microservices.md" >}})) that all have to somehow individually verify the authentication. In this case JWT can help not needed all these to have access to the [Web Sessions]({{< relref "20231102113142-web_sessions.md" >}}) data store, this become simple as the token will be signed by a trusted entity that the different services trust and they just need to have it's public key(See [PKI]({{< relref "20230417085602-pki.md" >}})).
-   See [Ways to do it](#ways-to-do-it) section
-   Another example of stateless session using encrypted cookies: [vvo/iron-session](https://github.com/vvo/iron-session)


## Ways to do it {#ways-to-do-it}


### Auth {#auth}

Use of [JWT]({{< relref "20230301214248-jwt.md" >}}) for Auth means using JWT for stateful stuff mostly which i am not super convinced of


#### Send it via [Cookies]({{< relref "20230615111924-cookies.md" >}}) {#send-it-via-cookies--20230615111924-cookies-dot-md}

-   Cookie Hardening
-   Backend w proper [CORS]({{< relref "20230302210256-cors.md" >}}) policy


#### Send it via [HTTP]({{< relref "20230222161545-http.md" >}}) Bearer token with [TLS]({{< relref "20230210181907-tls.md" >}}) {#send-it-via-http--20230222161545-http-dot-md--bearer-token-with-tls--20230210181907-tls-dot-md}

-   This is what applications which are not Browsers do afaik
-   Can be vulnerable to [XSS]({{< relref "20230616121539-xss.md" >}})


### Info exchange/delegation of access {#info-exchange-delegation-of-access}


#### Sent it in API response and let client decide {#sent-it-in-api-response-and-let-client-decide}

-   Since the token is signed, we can just send it.
-   The client can decide how they want to use it, this is more useful in the [usecase of "Information Exchange"](https://jwt.io/introduction) compared to [Authentication]({{< relref "20230301191046-authentication.md" >}}).


### Use on [OIDC (OpenID Connect)]({{< relref "20230301191046-authentication.md#oidc--openid-connect" >}}) {#use-on-oidc--openid-connect----20230301191046-authentication-dot-md}

-   OIDC does not mandate the use of JWT as the `ID token` (JAR) / `access token`
    -   In fact there's no structure defined for the token, but using JWT has benefits.
    -   But OIDC tokens are transparent unlike OAuth(opaque tokens), So JWT fits!
-   Allows other flows (hybrid or implicit) to be used.
-   Good library support
-   Can hold payload
-   Signed token, so the RP can still trust it even though it's been received via an untrusted channel.
