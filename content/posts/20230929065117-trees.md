+++
title = "Trees"
author = ["Hrishikesh Barman"]
draft = false
+++

tags
: [Data Structures]({{< relref "20230403192236-data_structures.md" >}}), [Graphs]({{< relref "20230521010631-graphs.md" >}})


## Tree Traversal {#tree-traversal}


### Meta ideas about tree traversal {#meta-ideas-about-tree-traversal}

-   We usually just go L -&gt; R


#### Complexity {#complexity}

-   All trees have `n - 1` edges, `n` being the number of nodes.
-   Time complexity: `O(V + E)` &rArr; \\(O(n + (n-1)) = O(n)\\)


#### About {in,pre,post}order {#about-in-pre-post-order}

-   BFS doesn't have `{in,pre,post}order`, those are DFS specific.
-   `{pre,post}order` work for `n-ary` trees, while [inorder becomes a little weird](https://stackoverflow.com/questions/66980517/tree-traversal-pre-and-postorder-for-general-trees-inorder-only-for-binary-tr) for anything that's not a binary tree.


#### Recursion and traversal {#recursion-and-traversal}

|           | BFS (Queue)         | DFS (Stack)                                     |
|-----------|---------------------|-------------------------------------------------|
| Recursive | Not natural         | Yes, that's the way. Preserves shape/structure. |
| Iterative | Yes, that's the way | Unsual to do, might help w limited call stack   |

-   See [Recursive process vs Recursive procedure]({{< relref "20230429205506-recursion.md" >}})


### DFS (Stack) {#dfs--stack}

![](/ox-hugo/20230205172402-algorithms-1202411924.png)
![](/ox-hugo/20230929065117-trees-328537490.png)

-   **Workhorse:** push and pop things on a `stack` (call stack)


#### Preorder {#preorder}

-   `VisitNode() + RecurseL() + RecurseR()`
-   Root's in the beginning


#### Inorder {#inorder}

-   `RecurseL() + VisitNode() + RecurseR()`
-   Root's in the middle
-   Inorder traversal of a Binary search tree will print things in order


#### Postorder {#postorder}

-   `RecurseL() + RecurseR() + VisitNode()`
-   Root's in the end


#### Implementation {#implementation}

-   Recursive
    -   DFS uses a stack to maintain a frontier, and recursion has an implicit stack (call stack)
    -   Implementing DFS using recursion simply means replacing the stack with a call stack.
-   Iterative
    -   To convert it into an iterative DFS you can simply use an actual stack data structure, but you now need to manage the stack yourself.


### BFS (Queue) {#bfs--queue}

{{< figure src="/ox-hugo/20230205172402-algorithms-1385823146.png" >}}

-   **Workhorse:** enqueue and dequeue things on a `queue` (auxiliary storage)

<!--listend-->

```text
while !q.empty?
  curr = q.rm_from_start() // dequeue
  print(curr) // do whatever w curr
  q.enqueue(curr.l)
  q.enqueue(curr.r)
```


#### Implementation {#implementation}

-   Mostly uses a queue
-   BFS and [recursion cannot be combined](https://codeforces.com/blog/entry/18642) as naturally since BFS does not use a stack
