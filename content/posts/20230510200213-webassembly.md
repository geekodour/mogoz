+++
title = "WebAssembly"
author = ["Hrishikesh Barman"]
draft = false
+++

tags
: [Web Development]({{< relref "20221108105344-web_development.md" >}}), [Web Performance]({{< relref "20230503160302-web_performance.md" >}}), [Systems]({{< relref "20221101150250-systems.md" >}})

> Note: This is just some initial exploration. Idk shit, all of this is 90% wrong, there's a 100% chance of that.


## What? {#what}

-   It was initially meant for browsers but ppl build own standalone WebAssembly runtimes to run Wasm server-side


### Hierarchy in case of WASM {#hierarchy-in-case-of-wasm}

`ISA < Platform < Runtime`


#### ISA {#isa}

The arch. Eg. x86_64, arm64

-   `wasm32`. This is what we mean when we say compile down to webassembly.
-   `wasm32` code currently runs on a vm on top of existing ISAs.
-   It includes a “stack”, which records operand values and control constructs, and an abstract store containing global state. For each instruction, there is a rule that specifies the effect of its execution on the program state


#### Platform/ABI {#platform-abi}

These expose an ABI to the from `host` to the webassembly `vm`

-   Web Browser is one platform, usually using `emscripten`. `emscripten` defines its own ABI.
-   `wasi` is another platform. `wasi` specifically is barebones, it's like a headerfile, it needs a runtime.
-   Go defines it own ABI.


#### Runtime {#runtime}

Runtimes execute WebAssembly Modules, which are most often binaries with a `.wasm` extension. They facilitates all of the necessary interactions between the vm(ISA) and the environment in which that VM exists(platform).

-   The webassembly runtimes in browsers
-   But webassembly code can also run outside browsers as-well either via `wasi` or `directly` or something like `assemblyscript`.
-   Eg. wasmer, wasmtime, WAVM, wazero etc. see [list of webassembly runtimes](https://github.com/appcypher/awesome-wasm-runtimes#webassembly)


### Webassembly Code {#webassembly-code}

This is what consists a webassembly module (`.wasm` file) that runtimes execute.


#### Compiling {#compiling}

-   `emscripten` : Initially used to compile to `asm.js`, now supports `webassembly`
-   zig : Supports `freestanding`, `wasi`
-   Rust, go and others has compilation flags
-   Other supports/custom ways etc.


#### Writing by hand {#writing-by-hand}

-   WebAssembly binary format [has a text representation](https://github.com/WebAssembly/wabt) — the two have a 1:1 correspondence.
-   You can write or generate this format by hand and then convert it into the binary format.
-   [AssemblyScript](https://www.assemblyscript.org/) TS based programming language that compiles to webassembly. Recently [removed support for wasi](https://news.ycombinator.com/item?id=32562230)


## More on Runtimes {#more-on-runtimes}


### WASI {#wasi}

-   One of the goals of WASI however is to define a strict sandbox such that it becomes simple for a host environment to decide exactly what resources to share with a WebAssembly module.
-   Some ppl say jvm = wasi+wasm. I am not so sure of this argument, have to see for myself.
-   [stealthrocket/wasi-go: A Go implementation of wasi](https://github.com/stealthrocket/wasi-go)
-   [WASIX, the Superset of WASI Supporting Threads, Processes and Sockets | Lobsters](https://lobste.rs/s/aksady/wasix_superset_wasi_supporting_threads)


## Usecases {#usecases}

Random use cases from internet

-   I use WASM instances as isolated containers for processing data in my pet project. Once you compiled the WASM module and kept it in memory, spawning instances is incredibly fast!
-   I think WASM can become the perfect scripting solution for games, ERP, or CRM-like types of SaaS!
