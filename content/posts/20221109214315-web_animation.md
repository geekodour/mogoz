+++
title = "Web Animation"
author = ["Hrishikesh Barman"]
draft = false
+++

tags
: [Web Development]({{< relref "20221108105344-web_development.md" >}})

{{< figure src="/ox-hugo/20221109214315-web_animation-2001374474.png" >}}


## Graphics on the web {#graphics-on-the-web}


### Visual Media {#visual-media}

AFAIK there are [3 types of visual media](https://developer.mozilla.org/en-US/docs/Web/Guide/Graphics) that browsers as of today can present.

-   Images
    -   Bitmap, Vector images(SVG)
    -   See [Image Compression]({{< relref "20230113141102-image_compression.md" >}})
-   On the fly 2D and 3D graphics
    -   Canvas API, WebGL, WebGPU
    -   Using `<canvas>` element
-   Video


#### Displaying visual media {#displaying-visual-media}

AFAIK, to display visual media to humans, we need 3 things

-   A renderer: SVG, Canvas API, WebGL, WebGPU
-   A way to talk to the renderer: [Javascript]({{< relref "20221126085225-javascript.md" >}})
-   A place where a renderer can display what it's going to render: HTML DOM


### The HTML DOM {#the-html-dom}

{{< figure src="/ox-hugo/20221109214315-web_animation-657537458.png" >}}

-   It is the ultimate playground for graphics on the web.
-   Supports general things: Positioning, CSS layout, CSS transitions etc.
-   Renderers
    -   SVG: Since SVG is directly written into the DOM, we can do almost everything we can do with other dom elements.
    -   Canvas API, WebGL, WebGPU: Provides support via `<canvas>` element.


### Renderers {#renderers}

![](/ox-hugo/20221109214315-web_animation-1435799650.png)
Answer to when to use these is, "it depends".


#### SVG (via HTML) {#svg--via-html}

-   Vector based
-   SVG is not really a renderer(?) but works out as one in our case. It directly plugs into the DOM transparently and allows us to style with CSS, and have events w js like other HTML elements.

<!--list-separator-->

-  When to use?

    -   When we need vector stuff, easily displayed on smaller screens etc.

<!--list-separator-->

-  Issues

    -   If the number of objects is too high, it'll usually become a bottleneck because of reflow/repaint


#### Canvas API {#canvas-api}

-   Bitmap based

<!--list-separator-->

-  When to use?

    -   When SVG is not cutting it for performance and using WebGL would be too extra

<!--list-separator-->

-  Issues

    -   Mostly backbox debugging as not into the DOM


#### WebGL {#webgl}

{{< figure src="/ox-hugo/20230326125239-creative_programming-845651763.png" >}}

-   Uses GLSL under the hood and talks to the GPU

<!--list-separator-->

-  When to use?

<!--list-separator-->

-  Issues

    -   Mostly backbox debugging as not into the DOM


#### WebGPU {#webgpu}


## Interactivity {#interactivity}


## Animations {#animations}


### CSS animations {#css-animations}


### SVG animations {#svg-animations}

{{< figure src="/ox-hugo/20230326125239-creative_programming-617920571.png" >}}

-   SVG animations where things are animated in AE
-   w SVG animations you can pause things at some point, you can't do that directly w css animations


### WebGL animations {#webgl-animations}


### Canvas API animations {#canvas-api-animations}


### WebAnimation API {#webanimation-api}


### Other libraries for animation {#other-libraries-for-animation}

-   [Framer Motion]({{< relref "20230107212601-framer_motion.md" >}}) is a wrapper around CSS animations
-   Motion.dev is a wrapper around WebAnimationAPI(WAAPI)


## More on animations {#more-on-animations}


### The levels of web animation {#the-levels-of-web-animation}

I found this [excellent comment](https://www.reddit.com/r/Frontend/comments/ly6squ/comment/gpr68un/) on reddit, this is the summarization:

-   Level0 (State change): State change effects, hover, focus etc.
-   Level1 (Class transitions): Class change effects, changes that take place when class is changed. Class is changed with JS.
-   Level2 (CSS animations): Whenever we need keyframe animations, like spinners.
-   Level3 (Moving in/out of DOM)
    -   This is fine for out of flow things like tooltip and stuff
    -   For static things, where you know the size of the content(eg. accordion) you can use max-height etc.
    -   For more dynamic things, you'll have to use JS for that to measure the size of elements before and after they're visible.
-   Level4 (Scroll transitions)
    -   They can be as simple as using JS to detect when an element becomes visible and use basic state transitions
    -   But it can also be complex, like really using the scroll distance to play the transition as the scroll happens
-   Level5 (Page transitions)
    -   If you have the index page of a blog with list of posts that have an image and a title
    -   the page transition would be that on click on a post, the post thumbnail moves to become the background of the page and the titles moves as well
    -   before the rest of the content appears, as if you'd never left the page.

I feel like these level approach is nice but can be improved and extended. I should come back and improve this list someday.
