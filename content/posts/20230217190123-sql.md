+++
title = "SQL"
author = ["Hrishikesh Barman"]
draft = false
+++

tags
: [Database]({{< relref "20221102123145-database.md" >}}), [PostgreSQL]({{< relref "20221102123302-postgresql.md" >}})


## FAQ {#faq}


### Document Data Model (NoSQL) {#document-data-model--nosql}

![](/ox-hugo/20230217190123-sql-51728771.png)
![](/ox-hugo/20230217190123-sql-1802579951.png)


### History? {#history}

-   Berkeley, for `Ingress` had `QUEL`
    -   `Ingress` roots [PostgreSQL]({{< relref "20221102123302-postgresql.md" >}})
-   IBM, for `System R` first came up w `SQUARE`
    -   `System R` roots `System/38`, `DB2`
    -   `SQUARE` was complicated, so needed something else.
    -   Came up with `SEQUEL`, wordplay on `QUEL` (sequel to `QUEL`)
    -   Later renamed `SEQUEL` to `SQL`


## SQL and Relational Algebra {#sql-and-relational-algebra}

<div class="warning small-text">

> -   SQL is based on **bags (duplicates)** not **sets (no duplicates)**.
> -   So this is where SQL differs from relation algebra
</div>


### DML and DDL {#dml-and-ddl}

-   DML
    -   Methods to store and retrieve information from a database.
    -   Procedural
        -   Query specifies a high-level "How" based on sets.
        -   This is Relational Algebra
    -   Non-Procedural (Declarative)
        -   Query specifies only what data is needed.
        -   This is Relational Calculus
-   DDL
    -   Index creation, table creation deletion etc.
-   DCL (Data control language)
    -   Access control etc.


### Operators {#operators}

{{< figure src="/ox-hugo/ra_hand_note.jpg" >}}

-   relational algebra is a logical definition of what a plan should do


### Ordering {#ordering}

-   Ordering is important, do we want to join 1bnx1bn and then pick columns or do we want to join 1bnx2cols. The latter is better.
    ![](/ox-hugo/20230217190123-sql-89523410.png)
-   This translates to execution strategy/query plan
-   Modern optimizers can sometime help you do this automatically but sometimes it gets things wrong.
-   TIP: Don't prematurely optimize, write your query normally, see what the optimizer does, if not what you need, change your query/provide hints/provide index etc.


### Practicality {#practicality}

-   SQL has a standard but almost every dbms vendor offends the standard


## 101 Basics {#101-basics}


### Aggregations (on rows) {#aggregations--on-rows}

{{< figure src="/ox-hugo/20230217190123-sql-286460954.png" >}}

-   Functions that return a single value from a bag of `tuples`
-   Aggregate functions can **(almost) only be used** in the `SELECT` output list.
-   Support/Rules
    -   `COUNT, SUM, AVG` support `DISTINCT`
    -   Multiple aggregates in a `SELECT` query is allowed
    -   Output of other columns when doing aggregates is undefined. (instead use `GROUP BY`)
    -   Non-aggregated values in `SELECT` clause must appear in `GROUP BY` clause.
    -   Filtering on the aggregated value is done using `HAVING`, syntax looks like we're computing `AVG` twice, but the database is smart enough not to do that. We use `HAVING` because `WHERE` is not aware of the computed value.
        ![](/ox-hugo/20230217190123-sql-2019727508.png)
-   Examples
    -   `COUNT(col)`: Return # of values for col.
    -   `SUM(col)`: Return sum of values in col.
    -   `AVG(col)`: Return the average col value.
    -   `MIN(col)`: Return minimum col value.
    -   `MAX(col)`: Return maximum col value.


### String operations {#string-operations}

{{< figure src="/ox-hugo/20230217190123-sql-1746515094.png" >}}

-   `LIKE` : `%` (any substring), `_` (one character)
-   Operations: Can be used in `output` or in `predicate`
    -   Eg. `SUBSTRING`, `UPPER`, `||/+/CONCAT`,  DBMSes add their own shit


### Date/Time {#date-time}

-   Can be used in `output` or in `predicate`


## Random topics {#random-topics}

-   window functions
-   inequality joins
-   quantile functions
-   "say you have a dataset in a SQL table, and you find there are duplicates in it that shouldn't be there. walk me through how you'd resolve this issue"
    -   I've also encountered the same thing, but with constraints added every time you come up with a solution.
    -   Whay if the table has a billion rows, would that affect your solution?
    -   What if you need to ensure it completes before every full hour?
    -   What if new data arrives continuously?
