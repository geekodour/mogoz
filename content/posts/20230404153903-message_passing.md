+++
title = "Message Passing"
author = ["Hrishikesh Barman"]
draft = false
+++

tags
: [Distributed Systems]({{< relref "20221102130004-distributed_systems.md" >}}), [Inter Process Communication]({{< relref "20221101173527-ipc.md" >}}), [Concurrency]({{< relref "20221126204257-concurrency.md" >}})

> In my experience of reading articles and discussions related to Message Passing, it's apparent that the terms are not used very consistently. So don't make the mistake of being too pedantic about these terms, esp technologies.


## Messaging Patterns {#messaging-patterns}


### Streaming {#streaming}


### Pub/sub {#pub-sub}


### Queue {#queue}


### Bus {#bus}


### Request/Reply {#request-reply}


### Distributed Log {#distributed-log}


## Message Queue (MQ) {#message-queue--mq}

-   One of more popular [Messaging Patterns](#messaging-patterns)
-   Async communication on an infrastructural level
-   The `Queue` itself is just a data structure/container and usually needs a `Broker` (Queue Manager)


### Message Broker (Queue Manager) {#message-broker--queue-manager}

Sort of middleware that can handle things like routing, validate, store, deliver stuff


#### Routing layer {#routing-layer}


#### Other {#other}

-   Implicit/explicit limits on the size of data in a message, no. of messages outstanding on the queue etc.


### Queue {#queue}

-   Data structure
-   other
    -   Dead letter queue


#### Nature {#nature}


### Usecases {#usecases}

-   Distributed [Task Queue]({{< relref "20230404163634-task_queue.md" >}})
-   Used in Event-driven architectures
-   [Dead letter queue - Wikipedia](https://en.wikipedia.org/wiki/Dead_letter_queue)


## Implementations {#implementations}

Different implementations have different tradefoff, I am just listing random things. Analyze the situation at hand and decide for yourself. Different implementations can support/not support different message passing patterns.


### Broker {#broker}


#### RabbitMQ {#rabbitmq}

-   A message router
-   Supports various protocols: AMQP, HTTP, WS, STOMP, MQTT
-   Can be tricky to administer.


#### Redis {#redis}

-   Redis is a fast in-memory key-value store with optional persistence.
-   The message queue/ pub sub feature of Redis is a secondary use case. Hence, abilities are simpler than RabbitMQ.
-   But it [can be used](https://docs.celeryq.dev/en/stable/getting-started/backends-and-brokers/index.html) as a [message queue](https://redis.io/commands/lmove/)


#### ActiveMQ {#activemq}


#### NATS {#nats}

<!--list-separator-->

-  NATS core

<!--list-separator-->

-  NATS streaming


#### NSQ {#nsq}

-   <https://nsq.io/>
-   No builtin support for replication
-   Looses in-memory things if crashes
-   Pub/Sub


### Distributed {#distributed}


#### Kafka {#kafka}

-   See [Kafka]({{< relref "20230210012126-kafka.md" >}})


### Brokerless {#brokerless}


#### ZMQ (ZeroMQ) {#zmq--zeromq}

-   zmq is a communication library, not an application.


#### NanoMQ {#nanomq}

Original Nanomsg is abandoned. There's [nng](https://nng.nanomsg.org/) which is a lightweight, broker-less library. People on the internet say it's inferior to ZMQ.


### Others {#others}

-   [PostgreSQL]({{< relref "20221102123302-postgresql.md" >}}) via NOTIFY/LISTEN
-   NATS with jetstream is conceptually closer to Apache Pulsar than Kafka.
-   Liftbridge (<https://liftbridge.io/>) is more or less the NATS Kafka versioning.


## Protocol {#protocol}

See [Custom Protocols]({{< relref "20230221012237-custom_protocols.md" >}})


### AMQP {#amqp}

-   It's a [feature-rich](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) message queue binary protocol, that [brokers](https://www.rabbitmq.com/protocols.html) can use.


### MQTT (Protocol) {#mqtt--protocol}

-   Lightweight message queue protocol especially for embedded devices
-   A pub/sub platform
