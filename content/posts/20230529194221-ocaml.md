+++
title = "Ocaml"
author = ["Hrishikesh Barman"]
draft = false
+++

tags
: [Functional Programming]({{< relref "20221125204135-functional_programming.md" >}}), [Programming Languages]({{< relref "20221101220306-programming_languages.md" >}})

> In the early ’80s, there was a schism in the ML community with the French on one side and the British and US on another. The French went on to develop CAML and later Objective CAML (OCaml) while the Brits and Americans developed Standard ML. The two dialects are quite similar. Microsoft introduced its own variant of OCaml called F# in 2005.


## Intro {#intro}

-   Objective Categorical Abstract Machine language
-   ML: Meta Language


### Mutability {#mutability}

-   OCaml is primarily an immutable language, like most functional languages.
-   It does support imperative programming with mutable state, but we can probably not use it


### Types {#types}

-   Infer (Type checker will already do this)
-   Annotate (Additional constraint for the type checker)
    -   Eg. `(e:t)` : Parentheses are required for type annotation


## Building blocks {#building-blocks}


### Syntax gotchas {#syntax-gotchas}

-   A design choice is made not to overload operators, eg. `*` and `*.` are different operators for ints and floats.
-   If statements explicitly want boolean guards and branches need to be of same type
-   use `camelCase` for identifiers
-   In ocaml we say, we `apply` a function than `call` it.
-   Equality
    -   `=` and `<>` examine structural equality whereas (This is what we want to use)
    -   `==` and `!=` examine physical equality.
-   `begin..end` are equivalent to `()`


#### Functions {#functions}

> -   Functions are `values` and the body of the function is not evaluated unless applied.
> -   Functions can be used as `arguments`
> -   Functions can be returned as `result`

<!--list-separator-->

-  Anonymous Function (Lambda expressions)

    -   syntax: `fun x1 ... xn -> e`
    -   `\lambda x .e`
    -   Eg. : `fun x -> 42`

<!--list-separator-->

-  Named

    -   `let poop x = x+1;`
    -   `let poop = fun x -> x+1;`

<!--list-separator-->

-  Recursive

    -   `let rec poop = poop;`
    -   Mutually recursive functions can be written using `and`. 3110 book has a funny odd even example in Chapter2.4

<!--list-separator-->

-  No multi argument functions

    -   It might seem we can pass multiple arguments to ocaml, but that's not what actually happens
    -   `fun x y -> e` is syntactic sugar for `fun x -> (fun y -> e)`
    -   `let add x y = x +y` is syntactic sugar for `let add = fun x -> fun y -> x +y`

<!--list-separator-->

-  Polymporphic Functions

    {{< figure src="/ox-hugo/20230529194221-ocaml-75438668.png" >}}

    -   Eg. `let id x = x;;`
    -   `'a` : alpha (A type variable)


#### Operators {#operators}

-   Defining `infix` binary operators, we must wrap the operator in parens.
    -   Eg. `let ( <^> ) x y = max x y;;`, while `let <^> x y = max x y;;` will give you errors. btw not using simply `^` because that's the concat operator in ocaml.


### Semantic gotchas {#semantic-gotchas}


#### Others {#others}

-   `Unit` values: Eg. `assert e` evaluates to a `unit` value and nothing happens if `e` is `true`
    -   For the `Unit` type, there's only one value: `()`
    -   It's usually using code that has side effects. Printing is an example of a side effect: it changes the world and can’t be undone.
    -   Special syntax that can be used to chain together multiple functions that return unit.
        -   The expression `e1; e2` first evaluates `e1`, which should evaluate to `()`, then discards that value, and evaluates `e2`.
        -   This can be used to chain multiple print statements together which usually evaluate to `Unit`.


### Value and Expression {#value-and-expression}

{{< figure src="/ox-hugo/20230529194221-ocaml-1786262802.png" >}}


#### Values {#values}

Do not need any further evaluation


#### Expressions {#expressions}

{{< figure src="/ox-hugo/20230529194221-ocaml-1164254858.png" >}}

-   Syntax rules
-   Semantics
    -   Type checking rules
    -   Evaluation checking rules

<!--list-separator-->

-  `let` expression

    -   This give a notion of **scope**
    -   Eg. `let x = 2 in x` (let expressions, we can use this inside other expressions)
    -   Here we're binding a value to `x`
    -   Outside of this expression it'll not be bound to `x` whereas in case of `let` definition, it'll be bound to.

<!--list-separator-->

-  nested `let` expression w same variable name

    -   `let x = 5 in (let x = 6 in x)`
    -   What this expression is evaluate to is the last `x`.
    -   In ocaml, things are not mutable. So, `x` will not be redefined.
    -   Order is left to right
        -   `let x = 5 in ...` : Alright, x is assigned 5 for that scope
        -   `let x = 6 in x` : A new x is assigned here, and evaluated to `x`
        -   `x` is returned. we get 6.(from the `innermost scope`). i.e `let x = 5 in 6`
        -   But we never used the older `x`. So the older `x` remain unused.
        -   In other words, ocaml will not let us substitute the older value of `x` in the nested expression because it'll violate Principle of Name Irrelevance
    -   It's usually good not to mix the same variable name like this. You cannot get to the top level from the inner most level anyway for that `x`.


### Definitions {#definitions}

{{< figure src="/ox-hugo/20230529194221-ocaml-775671431.png" >}}


#### `let` definition {#let-definition}

{{< figure src="/ox-hugo/20230529194221-ocaml-903537241.png" >}}

-   These are like variable
-   These are NOT expressions, it does not have a value itself. (`let` expression and `let` definition are different things)
-   Eg. `let x = 2` (let definition)
    -   This implicitly means, `let x = 2 in "rest of what i type"`
    -   When we do `x=4;;x=7` etc. we're not mutating `x`, we're defining new `x` in a new scope. (So if you do this in ocaml toplevel/utop, you won't be able to access previously defined `x` but in files and programs we'll be do so accordingly)


### Builtin Data Types {#builtin-data-types}

{{< figure src="/ox-hugo/20230529194221-ocaml-548662551.png" >}}


#### Lists {#lists}

{{< figure src="/ox-hugo/20230529194221-ocaml-1210093666.png" >}}

-   can be `nil` or we `cons`
-   These are recursive and parameterized(takes any type) list
-   `#show list`
-   Operations
    -   Prepend
        -   Constant time `O(1)`
        -   `'a -> 'a list -> 'a list`
        -   []~
        -   `::` is used for **construct objects in memory** (`cons`)
        -   `::` is a binary constructor, takes `'a` and `'a list`
        -   `::` is an infix constructor(the only one)
        -   1st element is `head`, rest of the elements are `tail`
        -   []~
    -   Appending
        -   Linear time `O(n)`
        -   `'a list -> 'a list -> 'a list`
        -   `[88] @ [77]`, this is [not recommended](https://stackoverflow.com/questions/6732524/what-is-the-easiest-way-to-add-an-element-to-the-end-of-the-list) in the hot path because lists are implemented as a singly linked list.
        -   The `@` is the append operator, not related to the apply operator


#### Records {#records}

{{< figure src="/ox-hugo/20230529194221-ocaml-633329557.png" >}}

-   `with` : Allows record copy. eg. `{poop with name = "something else"}`. Does not allow you to add new fields as that would change the type of the record.


#### Tuple {#tuple}

```ocaml
type time = int * int * string
let t = (10, 10, "am")
```

-   Order is relevant
-   `fst` and `snd` let you access tuple which are pairs


## Features {#features}


### Pattern Matching {#pattern-matching}

```ocaml
match e with
| 2 -> e0
| p1 -> e1
| p2 -> e2
| pi -> ei
| _ -> 1

(* - p1, p2, p3 are patern variables so will be bound to e1, e2, e3 *)
(* - _ will not be bound *)
```

-   Can be used for matching with `types, ints, strings, lists, records, tuples`
-   Pattern variables: Things that go after `|` after `with`
-   What it allows
    -   Match is the **shape** of the data
    -   Extract/Transform parts of the data
-   Typechecking
    -   `e` and `pi` need to have same type
    -   Whole match would have type of `ei`. All `ei` need to be of **same type**


#### Syntax Sugars {#syntax-sugars}

-   For pattern matching with the `last argument`, we can use the `function` keyword.
    ![](/ox-hugo/20230529194221-ocaml-1499281842.png)


### Pipeline operator {#pipeline-operator}

Pipeline (Reverse Application operator)

-   `succ (square (square (succ 3)));;`
-   v/s `5 |> succ |> square |> square [> succ;;`


### Custom Types {#custom-types}

```ocaml
type primary = Red | Green | Blue (*this is valid, i still don't understand why*)
```


### Variants {#variants}

-   Value that could be one of several possibilities
-   Each value is called a `constructor` and is separated with `|` (the use of word constructor is diff. from languages like c++)
    -   `constructor` name must begin with Uppercase
    -   `constructor` is a `value`
    -   `contructor` can carry along optional data with it using the `of` keyword
    -   `contructior` aka `tags`
-   Accessing variants can only happen via Pattern Matching
-   `constructor` can be constants or non-constants(which carry some value using `of`)
-   Variant Type
    ![](/ox-hugo/20230529194221-ocaml-2082176888.png)


### Options {#options}

-   `list` and `option` are type constructors. They construct other types but are not types themsleves.
    -   eg. `int list`, `a' list`, `int option` and so on
-   For options, we can use `Some` and `None` for `option`
    -   I think `Some` and `None` are variant wala `constructors`
-   Syntax&amp; Semantics
    -   `None` is a value of type `'a option`
    -   `Some e` is an expression of type `t option` if `e : t`. If `e ==> v` then `Some e ==> Some v`


## Environment {#environment}


### Tooling {#tooling}

-   opam : package manager
-   ocamlopt : native code compiler
-   ocamlc : bytecode compiler (less used)
-   toplevel/utop
    -   When using `#use` exit and reload the toplevel if debugging, sometimes previous load overloads or something.
    -   `-:` in utop means it's an anonymous definition


## Links and Resources {#links-and-resources}


### Books {#books}

-   [A Guided Tour - Real World OCaml](https://dev.realworldocaml.org/guided-tour.html)
-   [OCaml from the Very Beginning](https://johnwhitington.net/ocamlfromtheverybeginning/index.html)
-   <http://courses.cms.caltech.edu/cs134/cs134b/book.pdf>


## Notes from 3110 {#notes-from-3110}


### <span class="org-todo todo TODO">TODO</span>  {#d41d8c}

-   Skipping TDD: <https://cs3110.github.io/textbook/chapters/data/ounit.html#test-driven-development>
