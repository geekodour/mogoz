+++
title = "Threads"
author = ["Hrishikesh Barman"]
draft = false
+++

tags
: [Operating Systems]({{< relref "20221101172456-operating_systems.md" >}}), [Concurrency]({{< relref "20221126204257-concurrency.md" >}})

Each thread executes a thread function


## Types {#types}

|              | preemptive     | not preemptive                   |
|--------------|----------------|----------------------------------|
| parallel     | native threads | programs on different computers? |
| non-parallel | green threads  | coroutines                       |


### Native Threads {#native-threads}


### Green Threads {#green-threads}

-   Language agnostic idea, implementations differ.
-   User-level threads that are scheduled by a runtime/scheduler/library instead of the OS. They usually sit on top of OS threads.
-   Green threads have threading semantics, that means that you need to deal with mutexes, atomics, etc.
-   You should code as though the context can switch at any time
-   Python's greenlets. Golang has mix of greenthreads and os threads w goroutines etc.


### Coroutines {#coroutines}

See [Coroutines]({{< relref "20230516192836-coroutines.md" >}})


## Thread Safety {#thread-safety}

Libraries can be: Thread safe, Conditionally safe, Not thread safe


### Implementations {#implementations}


#### Avoid Shared State {#avoid-shared-state}

-   Re-entrancy
    -   Subroutine is called reentrant if multiple invocations can safely run concurrently, i.e execution and then safely be called again/re-enter before its previous invocations complete execution.
    -   See [Interrupts]({{< relref "20221101173720-interrupts.md" >}}), Soft IRQs are re-enterant functions.
-   Tread local storage
    -   It's just storage specific to the running thread
    -   Many threads can have a variable called `a`; `a` is local to each thread. One usage can be multiple threads accumulating information into a global variable with some kind of sync ofc.
-   Immutable objects
    -   What functional languages do


#### Cannot avoid shared state {#cannot-avoid-shared-state}

-   Mutual Exclusion
    -   Locks and stuff. See [Concurrency]({{< relref "20221126204257-concurrency.md" >}})
-   Atomic Operations


## pthreads (posix threads) {#pthreads--posix-threads}

-   A `pthread` can be either be created as
    -   A **joinable thread** (the default)
    -   A **detached thread** (cleaned up automatically when it terminates)
-   Thread cancellation are of three types(`pthread_setcanceltype`)
    -   sync
    -   async
    -   uncancellable (critical section)


## Links {#links}

-   [pthread debuging](https://www.cs.swarthmore.edu/~newhall/unixhelp/gdb_pthreads.php)
-   [Rethinking the futex API {LWN.net}](https://lwn.net/Articles/823513/)
-   [You could have invented futexes | Hacker News](https://news.ycombinator.com/item?id=35708331) ðŸŒŸ
-   [Raw Linux Threads via System Calls](https://nullprogram.com/blog/2015/05/15/)
-   [Practical libc-free threading on Linux](https://nullprogram.com/blog/2023/03/23/)
-   [MutexProtected: A C++ Pattern for Easier Concurrency | Hacker News](https://news.ycombinator.com/item?id=35464152)
