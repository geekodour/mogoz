+++
title = "Golang"
author = ["Hrishikesh Barman"]
draft = false
+++

tags
: [Programming Languages]({{< relref "20221101220306-programming_languages.md" >}}), [Concurrency in Golang]({{< relref "20230412015037-concurrency_in_golang.md" >}})


## Compiling, Linking and OS dependencies {#compiling-linking-and-os-dependencies}


### Syscalls {#syscalls}


#### How does go make syscalls? {#how-does-go-make-syscalls}

-   [Differs](https://www.reddit.com/r/rust/comments/n8iq0f/how_does_the_rust_standard_library_work/) by [Operating](https://www.reddit.com/r/golang/comments/lapzam/go_116_will_make_system_calls_through_libc_on/) [system](https://groups.google.com/g/golang-nuts/c/uX8eUeyuuAY)
-   In Linux, because it has a [stable ABI](https://stackoverflow.com/questions/55735864/how-does-go-make-system-calls), it makes the syscalls directly skipping `libc`. w Linux, the kernel to userspace interface is stable(which syscalls use), but the [in kernel interfaces are not stable](https://github.com/torvalds/linux/blob/master/Documentation/process/stable-api-nonsense.rst).
-   Enabling or disabling `CGO` has nothing to do with whether or not go syscall goes via `libc`, the C code used via `CGO` ofcourse will use `libc`.
-   Go does create wrappers around some syscalls (TODO: Need to dig into this)
-   Support for different syscalls in different OS is incremental. Eg. If `X` syscall is available in OS `A` and `B`. Go might have support for `X` only in `A` as of the moment.


#### Places where go handles syscalls {#places-where-go-handles-syscalls}

-   Try `fd syscall -t` on the go source tree.
-   [/syscall](https://pkg.go.dev/syscall@go1.20.2) : [Frozen](https://www.reddit.com/r/golang/comments/jt1qfm/syscall_package_deprecated_question/), except for changes needed to maintain the core repository.
-   [/internal/syscall](https://pkg.go.dev/internal/syscall@go1.20.2) : internal
-   [/runtime/internal/syscall](https://pkg.go.dev/runtime/internal/syscall) : internal, [some details](https://utcc.utoronto.ca/~cks/space/blog/programming/GoSchedulerAndSyscalls)
-   [/x/sys](https://pkg.go.dev/golang.org/x/sys)
    -   This is where new stuff goes and should be used by callers
    -   Contains 3 packages to hold their syscall implementations(Unix, Windows and Plan 9)
    -   Has the wrapper creation libraries such as [mkwinsyscall.go](https://cs.opensource.google/go/x/sys/+/refs/tags/v0.6.0:windows/mkwinsyscall/mkwinsyscall.go) and [mksyscall.go](https://cs.opensource.google/go/x/sys/+/refs/tags/v0.6.0:unix/mksyscall.go)


### Portability {#portability}

-   syscalls are not portable by nature, they are specific to the system. We need to add a build tag for the ARCH and OS that syscall invocation is valid for.


### Dynamic and Static Linking {#dynamic-and-static-linking}


#### Static linking {#static-linking}

<!--list-separator-->

-  Directly

    -   `CGO_ENABLED=0 go build`
    -   [Matt Turner - Statically Linking Go in 2022](https://mt165.co.uk/blog/static-link-go/)

<!--list-separator-->

-  musl

    -   [Statically compiled Go programs, always, even with cgo, using musl](https://honnef.co/articles/statically-compiled-go-programs-always-even-with-cgo-using-musl/)
    -   You can also statically link with musl, but note that musl lacks features that people might want to use non-pure Go in the first place. For example, musl does't support arbitrary name resolvers, e.g. no LDAP support; it only supports DNS, just like the pure Go net package.
    -   On the other hand musl does support os/user.

<!--list-separator-->

-  glibc

    -   **STATIC LINKING OF GLIBC IS DISCOURAGED**
    -   It [makes extensive](https://stackoverflow.com/questions/57476533/why-is-statically-linking-glibc-discouraged) internal use of `dlopen`, to load [nsswitch]({{< relref "20230228000520-nsswitch.md" >}}) modules and `iconv` [conversions](https://man7.org/tlpi/api_changes/index.html).


#### Dynamic linking {#dynamic-linking}

<!--list-separator-->

-  glibc versioning

    -   [GoAndGlibcVersioning](https://utcc.utoronto.ca/~cks/space/blog/programming/GoAndGlibcVersioning)

<!--list-separator-->

-  Other

    -   [Dynamic linking](https://drewdevault.com/dynlib.html)
    -   [A dynamic linking dependency problem in Golang](https://www.sobyte.net/post/2022-05/golang-dynamic-linking/)


### CGO {#cgo}

`CGO` is essentially utilizing C api calls to shared libraries exporting C interface. It is a [tradeoff](https://dave.cheney.net/2016/01/18/cgo-is-not-go).


#### Using CGO {#using-cgo}

-   `CGO_ENABLED=1`
-   Some things are only available as C libraries, re-implementing that in Go would be costly.
-   CGO is also used in some parts of standard library. Eg. ([net](https://pkg.go.dev/net#hdr-Name_Resolution) and os/user). It's not a strict requirement though, you can use these packages w/o CGO and they'll use stripped down version written in Go. But if you want the full thing, you have no other option than to enable `CGO`


#### Without using CGO {#without-using-cgo}

-   `CGO_ENABLED=0`
-   [GitHub - ebitengine/purego](https://github.com/ebitengine/purego)
-   [Introducing wazero from Tetrate - Tetrate](https://tetrate.io/blog/introducing-wazero-from-tetrate/?hss_channel=tw-998918265177952259)


### Cross Compilation {#cross-compilation}

See [Cross Compilation]({{< relref "20231031123241-cross_compilation.md" >}})


#### Cross compilation in Golang {#cross-compilation-in-golang}

-   Unless you're using a native cross compiler(eg. Clang, Golang Compiler), to cross-compile a program, you need to separately build and install a complete gcc+binutils toolchain for every individual arch that you want to target.
-   Which Go this is easy(cross compiler out of the box) + dependencies ensured to support.


#### Cross compilation and CGO {#cross-compilation-and-cgo}

`CGO` allows us to access C libraries in the system we're building/compiling on. It has no idea about C libraries of other systems. So mostly CGO is disabled by default if cross-compiling. However, if you need to cross-compile go code with `CGO`, you need a cross-compiling C compiler for the target machine. It can be done but it is a bit of PITA.

<!--list-separator-->

-  Using Zig

    -   See [this](https://zig.news/kristoff/building-sqlite-with-cgo-for-every-os-4cic) and [this](https://lucor.dev/post/cross-compile-golang-fyne-project-using-zig/)

    <!--listend-->

    ```shell
    CGO_ENABLED=1 GOOS=linux GOARCH=amd64 CC="zig cc -target x86_64-linux" CXX="zig c++ -target x86_64-linux" go build --tags extended
    ```

<!--list-separator-->

-  Naively Compiling

    -   Compile in an actual machine w of target directly
    -   You can [use chroot](https://blog.surgut.co.uk/2014/06/cross-compile-go-code-including-cgo.html)
    -   You can [use](https://dh1tw.de/2019/12/cross-compiling-golang-cgo-projects/) [containers](https://goreleaser.com/cookbooks/cgo-and-crosscompiling/)
    -   Other [stuff](https://github.com/FiloSottile/homebrew-musl-cross)


#### Others {#others}

-   [TinyGo](https://tinygo.org/)


## Packages and Modules {#packages-and-modules}

<div class="warning small-text">

> -   Read [Go Modules Reference](https://go.dev/ref/mod#glos-vendor-directory)
> -   module-aware mode is the way 2 go me fren. (GO111MODULE=""/auto)
> -   ditch gopath
</div>


### Meta notes {#meta-notes}

-   `package path` and `module path` may look similar, the difference lies in the existence of `go.mod` file inside the directory. i.e Repository root need not be the place where the `module` is defined.


### Packages {#packages}

-   `package path` / `import path`
    -   Identity of a package
    -   `module path` + subdirectory
    -   Eg. `golang.org/x/net/html`
-   Each directory that has Go source code inside, possibly including the root directory, is a `package`.
-   Example: `x/...` matches `x` as well as `x`'s subdirectories.


### Module {#module}

-   The tree(`module`) with branches(`packages`) and leafs(`*.go` files) growing on branches.
-   `packages` sharing the same lifecycle(`version number`) are bundled into a `module`.
-   `module path`
    -   Defined in the `go.mod` file by the `module directive`
    -   Identity of a module
    -   Acts as a prefix for `package` import paths within the module.
    -   Eg. `golang.org/x/net`, `golang.org/x/tools/gopls`


### Semantic versioning &amp; versions from VCS {#semantic-versioning-and-versions-from-vcs}

-   A version identifies an immutable snapshot of a `module`. Each version starts with the letter `v` + semantic versioning.
-   `v0.0.0, v1.12.134, v8.0.5-pre, v9.2.2-beta+meta and v2.0.9+meta` are valid versions.


#### VCS and pseudo versioning {#vcs-and-pseudo-versioning}

-   We can also get `modules` from VCS using `tags/branches/revisions/commits` that don’t follow semantic versioning.
-   In these cases, the go command will replace `golang.org/x/net@daa7c041` with `v0.0.0-20191109021931-daa7c04131f5`.
-   This is called `pseudo-version`. You usually won't be typing a pseudo version by hand.


#### Why separate directory for Major versions {#why-separate-directory-for-major-versions}

<div class="warning small-text">

> Golden rule:
> If an old package and a new package have the same import path
> &rArr; The new package must be backwards compatible with the old package.
</div>

-   `v0` / `pre-release` suffix: Unstable, doesn't need to be backwards compatible. No major version suffix directory allowed. So when starting new projects be under `v0` as long as possible.
-   `v1` : Defines the compatibility/stability. No major version suffix directory allowed.
-   `v2` / `v2+`  : Since major version bump by definition means breaking changes, by the golden rule, we need it to have separate module path.


### Building {#building}


#### What happens when go command tries to load a package? {#what-happens-when-go-command-tries-to-load-a-package}

-   When we try to load a `package`, indirectly we need to find the `module path`
-   It first looks into the `build list`, if not found it'll try to fetch the `module` (latest version) from a `module proxy` mentioned in the `GOPROXY` env var.
-   `go tidy` / `go get` does this automatically.


#### Generating build list {#generating-build-list}

-   When we run the go command, a list of final module versions is prepared from the `go.mod` file of `main module` + `transitively required modules` using minimal version selection. This final list of `module+version` is used for `go{build,list,test,etc}`. This is the `build list`
-   `// indirect` : This is added to `go.mod` of main module, when module is not directly required in the `main module`. So you should have all the dependencies in the `go.mod` file.


### Workspaces {#workspaces}

-   New feature 1.18+
-   You’re not meant to commit `go.work` files. They are meant for local changes only.
-   Has `use` and `replace` directives that can be useful for scratch work


### Module Proxy {#module-proxy}

-   module proxy is an HTTP server that can respond to GET requests for certain paths
-   We don't have a central package authority in the vein of `npm` or `crates.io`. Go modules have no `names`, only `paths`. The package management system uses the `package path/module path` to learn how to get the package. If it can't find the package locally, it'll try getting it from a `module proxy`.
-   module proxy related vars: `GOPRIVATE`, `GONOPROXY`, `GOPROXY="https://proxy.golang.org,direct"`
-   Different module proxies can have their own conventions (Eg. `gopkg.in` has some diff conventions)


#### Access private packages is a PITA {#access-private-packages-is-a-pita}

-   I haven't faced this issue yet, but for when I do.
-   [SuperQue comments on What “sucks” about Golang?](https://www.reddit.com/r/golang/comments/11o2yfd/what_sucks_about_golang/jbrxe7l/)
-   [languitar/pass-git-helper](https://github.com/languitar/pass-git-helper)


## Project organization and dependencies {#project-organization-and-dependencies}


### Standard Library {#standard-library}

-   In tree : You can find these in the go source tree. Check [Standard library](https://pkg.go.dev/std)
-   Out of tree : Part of go but out of tree, at `/x`. Check [Sub-repositories](https://pkg.go.dev/golang.org/x)


### Project structure {#project-structure}

<div class="warning small-text">

> -   multi-module monorepos is unusual
> -   multi-package monorepo is common
</div>


## Language topics {#language-topics}


### Pointers {#pointers}

-   There's no pointer arithmetic in go
-   Go guarantees that, thing being pointed to will continue to be valid for the lifetime of the pointer.
    ```go
    func f() *int {
            i := 1
            return &i
    } // Go will arrange memory to store i after f returns.
    ```


### Methods {#methods}

-   In general, all methods on a given type should have either value or pointer receivers, but not a mixture of both.


### Context {#context}


#### Signaling and Request cancellation {#signaling-and-request-cancellation}

-   Example: `a client timeout - > your request context is canceled - > every I/O operations and long running processes will be canceled too`
-   It's not possible for a function that takes a `context.Context` to cancel it
    -   It could do is `newCtx, cancel := context.WithCancel(origCtx)`.
    -   It can listen for `Done` on that `ctx` and do something(usually cancellation of ongoing task) based on it.
    -   `Done` is triggered
        -   when `cancel()` on the `ctx` is called. (requires `WithCancel`)
        -   also can be triggered based on use on `WithTimeout` and `WithDeadline`
    -   When a Context is canceled, all Contexts derived from it are canceled.
        -   Eg. when `cancel()` is called on `newCtx`, `newCtx` and all Contexts derived from it are canceled. (`origCtx` is NOT canceled)
        -   Eg. when `cancel()` is called on `origCtx`, `origCtx` and all Contexts derived from it are canceled. (`origCtx` and `newCtx` are canceled)
-   `context.Background()` is never canceled.


#### Storing values {#storing-values}

-   The storage of values in a context is [a bit controversial](https://dave.cheney.net/2017/01/26/context-is-for-cancelation). main use case for "context" is cancellation signals.
-   In the above example, `newCtx` will have access to the same values as `origCtx`
-   `context.Value()` is like Thread Local Storage (see [Threads]({{< relref "20221101173032-threads.md" >}}), [Concurrency]({{< relref "20221126204257-concurrency.md" >}})) for [goroutines]({{< relref "20230412015037-concurrency_in_golang.md" >}}) but in a cheap suit.


#### Other notes on context {#other-notes-on-context}

<!--list-separator-->

-  Context is that it should flow through your program.

    -   Imagine a river or running water.
    -   Do pass from function to function down your call stack, augmented as needed. (Usually as the first argument)
    -   Don't want to store it somewhere [like in a struct.](https://go.dev/blog/context-and-structs)
    -   Don't want to keep it around any more than strictly needed.

<!--list-separator-->

-  When to create context?

    -   Good practice to add a context to anything that might block on I/O, regardless of how long you assume it might take.
    -   Context object is created with each request and expires when the request is over. (request is general sense)
    -   `context.Background()`
        -   Use pure `context.Background()` ONLY to handle your app lifecycle, never in a io/request function.
        -   Just passing `context.Background()` there offers no functionality.
    -   `context.WithCancel`
        -   In io/request functions, use something like `context.WithCancel(context.Background())` because that'll allow you to cancel the context.
        -   Fresh context
            -   Eg. `context.WithCancel(context.Background())`, `context.WithCancel(context.TODO())`
        -   Derived context
            -   Eg. `context.WithCancel(someExistingCtx)`
    -   `context.TODO`
        -   Adding context to program later can be problematic, so consider using `context.TODO` if unsure what context to use. It's similar to using `context.Background()` but it's a clue to your future self that you are not sure about the context yet rather than you explicitly want a background context.

<!--list-separator-->

-  Separation of context

    -   General rule: If the work(i/o) you're about to perform can outlive the lifetime of outer function, you'd want to create a fresh context instead of deriving from the context of the outer function(if there is one)
        -   Eg. HTTP requests context are not derived from the server context as you still want to process on-going request while the app shuts down. (`IMPORTANT`). You'd use `http.Request.Context()`
    -   Think clearly about the boundaries and lifetimes, don't mess app context to handle async function, internal consumer or request etc.

<!--list-separator-->

-  Context package and HTTP package

    -   You can get the context from `http.Request` with `.Context()`. It’s like this is because the http package was written before context was a thing.
    -   `Outgoing client requests`, the context is canceled when
        -   We explicitly cancel the context
    -   `Incoming server requests`, the context is canceled when
        -   The client's connection closes
        -   The request is canceled (with HTTP/2)
        -   The ServeHTTP method returns

<!--list-separator-->

-  Context an Instrumentation

    -   Instrumentation libraries generally use the context to hold the current span, to which new child spans can be attached.


#### Resources on context {#resources-on-context}

-   More on context: [Break The Golang Context Chain » Rodaine](https://rodaine.com/2020/07/break-context-cancellation-chain/)
-   Even more: [Chris's Wiki blog/programming/GoContextValueMistake](https://utcc.utoronto.ca/~cks/space/blog/programming/GoContextValueMistake)
-   [justforfunc #9: The Context Package - YouTube](https://www.youtube.com/watch?v=LSzR0VEraWw)
-   [Go Class: 25 Context - YouTube](https://www.youtube.com/watch?v=0x_oUlxzw5A)


### Maps {#maps}

-   Go Maps are hashmap. O(1) ACR, O(n) WCR
-   A Map value is a pointer to a `runtime.hmap` structure.
-   Since it's a pointer, it should be written as `*map[int]int` instead of `map[int]int`. Go team changed this historically cuz it was [confusing anyway](https://dave.cheney.net/2017/04/30/if-a-map-isnt-a-reference-variable-what-is-it).
-   Maps change it's structure
    -   When you insert or delete entries
    -   The map may need to rebalance itself to retain its O(1) guarantee
-   What the compiler does when you use map
    ```go
    v := m["key"]     // → runtime.mapaccess1(m, ”key", &v)
    v, ok := m["key"] // → runtime.mapaccess2(m, ”key”, &v, &ok)
    m["key"] = 9001   // → runtime.mapinsert(m, ”key", 9001)
    delete(m, "key")  // → runtime.mapdelete(m, “key”)
    ```
-   If you want a map where you only care about the key and not the value, we can do: `set := make(map[string]struct{})` so it's assigned to empty struct.


### Embedding interfaces &amp; structs {#embedding-interfaces-and-structs}

-   It's not subclassing, but we can borrow types in `struct` and `interfaces`
-   See [Embedding in Go: Part 3 - interfaces in structs - Eli Bendersky's website](https://eli.thegreenplace.net/2020/embedding-in-go-part-3-interfaces-in-structs/)


#### Embedding Interface {#embedding-interface}

```go
// combines Reader and Writer interfaces
type ReadWriter interface {
    Reader
    Writer
}
```


#### Embedding Struct {#embedding-struct}

<!--list-separator-->

-  Embedding directly, no additional bookkeeping

    -   When invoked, the receiver of the method is the inner type not the outer one.
    -   i.e when the `Read` method of a `bufio.ReadWriter` is invoked, receiver is the inner `Reader` and not `ReadWriter`.

    <!--listend-->

    ```go

    // bufio.ReadWriter
    type ReadWriter struct {
        *Reader  // *bufio.Reader
        *Writer  // *bufio.Writer
    	*log.Logger
    }

    // - the type name of the field, ignoring the package
    //   qualifier, serves as a field name
    // - Name conflicts are ez resolvable
    var poop ReadWriter
    poop.Reader // refers to inner Reader
    poop.Logger // refers to inner Logger
    ```

<!--list-separator-->

-  Embedding in-directly, additional bookkeeping

    ```go
    type ReadWriter struct {
        reader *Reader
        writer *Writer
    }
    func (rw *ReadWriter) Read(p []byte) (n int, err error) {
        return rw.reader.Read(p)
    }
    ```


### Error and panics {#error-and-panics}

See [How we centralized and structured error handling in Golang | Hacker News](https://news.ycombinator.com/item?id=42447762)

-   `recover` only makes sense inside `defer`
-   `defer` can modify named return values
    -   We cannot return from `defer` but can use of named return values to have similar effect. eg. have a named return called `err` and set `err` in the defer function after recover.


#### Creation {#creation}

-   `errors.New`
-   `fmt.Errorf`
-   which one?


#### Error wrapping {#error-wrapping}

<https://lukas.zapletalovi.com/posts/2022/wrapping-multiple-errors/>

> you wrap to give context about what went wrong in the function you called. You do not wrap to say that the function you called failed.

-   using `fmt` like this: `fmt.Errorf("failed to create user: %w", err)` (Go1.13): Useful to add info context
    -   `fmt.Errorf` can also be used independently ofc when not wrapping error
    -   `%w` is meant for error arguments. (so this is the differentator)
-   Go1.20 introduced `errors.Join` and then make `fmt.Errorf` accept multiple `%w`. We can use either to join multiple errors. Eg. from goroutines.

<!--list-separator-->

-  Error wrapping in practice

    ```go
    package main

    import (
    	"errors"
    	"fmt"
    )

    // common HTTP status codes
    var NotFoundHTTPCode = errors.New("404")
    var UnauthorizedHTTPCode = errors.New("401")

    // database errors
    var RecordNotFoundErr = errors.New("DB: record not found")
    var AffectedRecordsMismatchErr = errors.New("DB: affected records mismatch")

    // HTTP client errors
    var ResourceNotFoundErr = errors.New("HTTP client: resource not found")
    var ResourceUnauthorizedErr = errors.New("HTTP client: unauthorized")

    // application errors (the new feature)
    var UserNotFoundErr = fmt.Errorf("user not found: %w (%w)",
        RecordNotFoundErr, NotFoundHTTPCode)
    var OtherResourceUnauthorizedErr = fmt.Errorf("unauthorized call: %w (%w)",
        ResourceUnauthorizedErr, UnauthorizedHTTPCode)

    func handleError(err error) {
    	if errors.Is(err, NotFoundHTTPCode) {
    		fmt.Println("Will return 404")
    	} else if errors.Is(err, UnauthorizedHTTPCode) {
    		fmt.Println("Will return 401")
    	} else {
    		fmt.Println("Will return 500")
    	}
    	fmt.Println(err.Error())
    }

    func main() {
    	handleError(UserNotFoundErr)
    	handleError(OtherResourceUnauthorizedErr)
    }
    ```

    "What may not look obvious from such artificial code snippet is that errors declarations are typically spread across many packages and it is not easy to keep track of all possible errors ensuring the required HTTP status codes. In this approach, all application-level wrapping errors declared in a single place also have HTTP codes wrapped inside them."


#### Error comparison {#error-comparison}

-   Value comparison
    -   Eg. `if err != nil {`
-   Type comparison
    -   Basically type assert but useful when we want to check error type
    -   Eg. `if nerr, ok := err.(net.Error) {`
    -   Eg. `if errors.As(err, &nerr) {` but need to intanciate first, `var nerr *net.Error`
-   Existence check
    -   This can be used when you wrap errors
    -   `if errors.Is(err, RecordNotFoundErr) {`


#### Error stacktrace {#error-stacktrace}

-   <https://github.com/palantir/stacktrace>


### Aliases {#aliases}

-   type byte = uint8
-   type rune = int32
-   type any = interface{}


### Interfaces {#interfaces}

-   Interfaces are just description of what something should resemble, by the methods.
-   The implementation of the interface can be done by a `struct`, `int`, `func` anything. Doesn't matter. You can define a method on a `func`, on a `int` just the same way you can define a method on a `struct`.


#### Interface and Pointers {#interface-and-pointers}

From chatgpt

> Certainly. The statement "interfaces in Go are already pointer-like" refers to how interfaces are implemented and behaved in Go. This is an important concept that affects how we pass and use interfaces in Go programs. Let's dive deeper into this:
>
> Interface Structure:
> In Go, an interface is represented internally as a two-word structure:
>
> The first word is a pointer to information about the type stored in the interface (called the "type descriptor").
> The second word is a pointer to the actual data.
>
> This structure is often referred to as an "interface value".
> Passing Interfaces:
> When you pass an interface to a function, you're actually passing this two-word structure. Even though it looks like you're passing by value, you're effectively passing a pointer to the data.
> No Need for Double Pointers:
> Because of this implementation, you don't need to use pointers to interfaces (like \*pgx.Tx) when you want to modify the underlying data. The interface itself already contains a pointer to the data.


### io stuff {#io-stuff}

Ben Johnson has great blogpost series covering these in good depth


#### Overview of io related packages {#overview-of-io-related-packages}

-   `io`
    -   Abstractions on `byte-stream`
    -   General io utility functions that don't fit elsewhere.
-   `bufio`
    -   Like `io` but with a buffer
    -   Wraps io.Reader and io.Writer and helps w automatic buffering
-   `bytes`
    -   Represent byte slice(`[]byte`) as `byte-stream` (`strings` also provide this)
    -   general operations on `[]byte`.
    -   `bytes.Buffer` implements `io.Writer` (useful for tests)
-   `io/ioiutil` (deprecated)
    -   `Deprecated`
    -   functionality moved to io or os packages


#### io {#io}

<!--list-separator-->

-  Reading

    -   `Read`
        -   returns `io.EOF` as normal part of usage
        -   If you pass an 8-byte slice you could receive anywhere between 0 and 8 bytes back.
    -   `ReadFull`
        -   for strict reading of bytes into buffer.
    -   `MultiReader`
        -   Concat multiple readers into one
        -   Things are read in sequence
        -   Eg. Concat in memory header with some file reader
    -   `TeeReader`
        -   Like the `tee` command. Specify an duplicate writer when reader gets read. Might be useful for debugging etc.

<!--list-separator-->

-  Writing

    -   `MultiWriter`
        -   Duplicate writes to multiple writers. Similar to `TeeReader` tho but happens when writing shit
    -   `WriteString`
        -   An performance improvement on `Write` on packages that support it. Falls back to `Write`

<!--list-separator-->

-  Transferring btwn Reading &amp; Writing

    -   `Copy` : Allocates a 32KB temp buff to copy from `src:Reader` to `dst:Writer`
    -   `CopyBuffer` : Provide your own buffer instead on letting `Copy` create one
    -   `CopyN` : Similar to copy but you can set a limit on total bytes. Useful when reader is continuously growing for example or want to do limited read etc.
    -   `WriteTo` and `ReadFrom` are optimized methods that are supposed to transfer data without additional allocation. If available, `Copy` will use these.

<!--list-separator-->

-  Files

    Usually, you have a continuous stream of bytes. But files are exceptions. You can do stuff like `Seek` w them.

<!--list-separator-->

-  Reading and Writing Bytes(uint8) &amp; Runes(int32)

    -   ByteReader
    -   ByteWriter
    -   ByteScanner
    -   RuneReader
    -   RuneScanner
    -   There's no RuneWriter btw


#### bytes and strings package {#bytes-and-strings-package}

Provides a way to interface in-memory `[]byte` and `string` as `io.Reader` and `io.Writers`

-   `bytes` package has 2 types
    -   `bytes.Reader` which implements `io.Reader` (`NewReader`)
    -   `bytes.Buffer` which implements `io.Writer`
-   `bytes.Buffer` is OK for tests etc
    -   Consider `bufio` for proper usecases w buffer related io.
    -   `bytes.Buffer` is a buffer with two ends
        -   can only read from the start of it
        -   can only write to the end of it
        -   No seeking


### strings, bytes, runes, characters {#strings-bytes-runes-characters}

-   Formal `for` loop will loop through `byte` in `string` but `for range` loop will loop through `rune`
-   `string` : Readonly slice of `bytes`. NOT slice of characters.
-   "poop" is a string. \`poop\` is a raw string.
    -   `string` can contain escape sequences, so they're not always UTF-8.
    -   `raw string` cannot contain escape sequences, only UTF-8 because Go source code is UTF-8. (almost always)
-   Unicode
    -   See [Unicode]({{< relref "20221126085853-unicode.md" >}})
    -   code point `U+2318`, hex val `2318`, (bytes `e28c98`) represents the symbol `⌘`.
-   `character`
    -   May be represented by a number of different sequences of `code points`
        -   i.e different sequences of UTF-8 bytes
    -   In Go, we call [Unicode]({{< relref "20221126085853-unicode.md" >}}) `code points` as `rune` (`int32`).


### Encoding {#encoding}


#### Encoding vs Marshaling {#encoding-vs-marshaling}

-   Usually these mean the same thing, but Go has specific meanings.
-   `x.Encoder` &amp; `x.Decoder` are for working w `io.Writer` &amp;  `io.Reader` (files eg.)
-   `x.Marshaler` &amp; `x.Unmarshaler` are for working w `[]byte` (in memory)


#### Encoding for Primitives vs Complex objects {#encoding-for-primitives-vs-complex-objects}

<!--list-separator-->

-  Primitive stuff

    -   bytes
        -   Text encoding(base64)/ binary encoding
        -   `encoding` package
            -   BinaryMarshaler, BinaryUnmarshaler, TextMarshaler, TextUnmarshaler
            -   These are not used so much because there’s not a single defined way to marshal an object to binary format. Instead we have [Custom Protocols]({{< relref "20230221012237-custom_protocols.md" >}}) which is covered w other packages such as `encoding/json` etc.
        -   `encoding/hex`, `encoding/base64` etc.
    -   integers
        -   `encoding/binary`, wen we needs endian stuff and variable length encoding
        -   For in-memory we have `ByteOrder` interface
        -   For streams we have `Read` and `Write`. This also supports composite types but better to just use [Custom Protocols]({{< relref "20230221012237-custom_protocols.md" >}}).
    -   string
        -   ASCII, UTF8
        -   `unicode/utf16`, `encoding/ascii85`, `golang.org/x/text`, `fmt`, `strconv` etc.

<!--list-separator-->

-  Complex obj stuff

    -   Complex objects is where [Custom Protocols]({{< relref "20230221012237-custom_protocols.md" >}}) comes in
    -   This is mostly about encoding more complex stuff like language specific data structure etc.
    -   Here we can go JSON, CSV, [Protocol Buffers]({{< relref "20230522131118-protocol_buffers.md" >}}), MsgPack etc etc.
    -   In a sense, [Database]({{< relref "20221102123145-database.md" >}})'es also encode data for us.
    -   Example packages: `encoding/json`, `encoding/xml`, `encoding/csv`, `encoding/gob`. Other external stuff is always there like [Protocol Buffers]({{< relref "20230522131118-protocol_buffers.md" >}}).


#### More on encoding/json {#more-on-encoding-json}

-   Encoding process
    -   For primitives we have in-built mapping for json
    -   For custom objects, it checks if types for `json.Marshaler`, if not then  `encoding.TextMarshaler`. Eg. `Time` implements `TextMarshaler` which creates RFC3339 string. Otherwise it builds it from primitives then that's cached for future use.
-   Decoding
    -   2 parts
        -   1st parse (Scanner)
        -   convert stuff to appropriate data type. Eg. Base 10 numbers to base 2 ints. (Decodestate) Uses reflect
    -   JSON is LL(1) Parsable. (See [Context Free Grammar (CFG)]({{< relref "20230422102551-context_free_grammar_cfg.md" >}})) so uses uses a single byte lookahead buffer
-   Also see (Nested JSON parsing)
    -   <https://github.com/tidwall/gjson>
    -   <https://github.com/Jeffail/gabs>
-   Also see JSON [Parsers]({{< relref "20230511160225-parsers.md" >}})
    -   <https://www.reddit.com/r/golang/comments/11l2h4i/highperformance_json_parsing_in_go/>
    -   <https://github.com/goccy/go-json>


### Generics in Go {#generics-in-go}


#### Current limitations {#current-limitations}

<!--list-separator-->

-  Co-variance

    You can't use

    ```nil
    RecipeServiceClient[
      templatefill.StartRequest,
      templatefill.StartResponse,
      templatefill.StopRequest,
      templatefill.StopResponse,
    ]
    ```

    where `RecipeServiceClient[any,any,any,any]` is expected. They're different types

    -   ATM, generic methods aren't supported (where the generic type is scoped to the method, instead of the parent type)
    -   i.e you can't have type parameters scoped to a particular method
    -   i.e Go's generics do not support covariance, which means that even though if T satisfies the any interface, Client[T] is not a Client[any], as these are distinct and mutually exclusive types and not interchangeable in either direction.


### Type Conversion and Type assertion {#type-conversion-and-type-assertion}


#### Type conversion {#type-conversion}

Eg. `interface{}(42)`, here we're taking 42(which is an int) and converting it into type `interface{}`


#### Type assertion {#type-assertion}

```go
package main

import "fmt"

type t int

//this will panic
// func main() {
//   i := interface{}(42)
//   _ = i.(t)
// }

// because we have two _, ok, this will not panic
func main() {
	i := interface{}(42)
	if _, ok := i.(t); !ok {
		fmt.Println("assertion failed")
		return
	}
	fmt.Println("not hmm")
}
```

-   Can be only done on interfaces. (Not limited to `interface{}` though, but has to be interface)


#### Type switch {#type-switch}

Main hatch: `switch c := v.(type)`

```go
// p := map[string]interface{}{}
p := map[string]any{}
err := json.Unmarshal(data, &p)
for k, v := range p {
    switch c := v.(type) {
    case string:
        fmt.Printf("Item %q is a string, containing %q\n", k, c)
    case float64:
        fmt.Printf("Looks like item %q is a number, specifically %f\n", k, c)
    default:
        fmt.Printf("Not sure what type item %q is, but I think it might be %T\n", k, c)
    }
}
```


### cgo {#cgo}

|         | Go Pointer, Pass to Go | Go Pointer, Pass to C       |
|---------|------------------------|-----------------------------|
| Go code | YES                    | YES, must point to C memory |
| C code  | NO                     |                             |

-   Go's pointer type can contain C pointers aswell as Go pointers
-   Go pointers, passed to C may only point to data stored in C


## Other topics {#other-topics}


### Deep copy {#deep-copy}

-   There's no default deep copy, if primitive types assigning is copy by value but if struct contains pointers etc, you'd need to implement the deep copy yourself


### time.Ticker {#time-dot-ticker}

> If an operation in a select case takes longer than the ticker duration (5 seconds in your case), the ticker will continue to tick every 5 seconds, but you'll miss those ticks while the operation is running. When the operation finally completes, the next case that reads from terminationCheckTicker.C will only get the most recent tick - any ticks that occurred during the operation are dropped.


### Application supervison {#application-supervison}

NOTE: We're running multiple services here, the idea is similar to erlang supervisor trees. See <https://www.jerf.org/iri/post/2930/>

But instead of using <https://github.com/thejerf/suture>, we're using oklog/run as suture doesn't seem to handle net/http (doesn't fit in the model). The idea is similar to errgroup package aswell.


## Application architecture {#application-architecture}

> -   Accept interfaces(broader types)
> -   Return structs(specific types)

-   See [Design Patterns]({{< relref "20221125204047-design_patterns.md" >}})
-   Watch [Workshop: Practical Go - GoSG Meetup - YouTube](https://www.youtube.com/watch?v=gi7t6Pl9rxE)
-   Watch [Dave Cheney - SOLID Go Design - YouTube](https://www.youtube.com/watch?v=zzAdEt3xZ1M)
-   Read [Go and a Package Focused Design | Gopher Academy Blog](https://blog.gopheracademy.com/advent-2016/go-and-package-focused-design/)
-   `Models` can be analogous to `type` (core)
-   `Controller` can be analogous to `handlers` (does not do core)
-   `Service things` these contain specific core logic etc.


### Handler vs HandlerFunc {#handler-vs-handlerfunc}

-   See [HandleFunc vs Handle : golang](https://www.reddit.com/r/golang/comments/lqv3nm/handlefunc_vs_handle/)
-   Anything(struct/function etc.) that implements the `http.Handler` interface
-   The interface has the `ServeHTTP` method for handling HTTP requests and generating response
-   Avoid putting business logic in handlers the same way you won't put business logic into controllers
-   `http.HandlerFunc` is an example of a handler (of type function) which implements `http.Handler`
-   When we write functions that contain the signature of `http.HandlerFunc` we've written a handler function.


### Logging and Error Handling {#logging-and-error-handling}

-   In short: log the error once, at the point you handle it.
    -   Only log the error where it is handled, otherwise wrap it and return it without logging.
    -   At some point, you will log it as either an error if there is nothing you can do about it, or a warning if somehow you can recover from it (not panic recover).
    -   However your log record will contain the trace from the point where the error occurred, so you have all the information you need.


## Testing {#testing}


### Note on `testing.Log` {#note-on-testing-dot-log}

-   When using t.Log
    -   this debug info printed only on test fail, else with -v. If program fails to compile nothing runs


## Go and Databases {#go-and-databases}

See [Organising Database Access in Go – Alex Edwards](https://www.alexedwards.net/blog/organising-database-access) 🌟


### Notes on using sqlc with golang {#notes-on-using-sqlc-with-golang}

-   [How We Went All In on sqlc/pgx for Postgres + Go](https://brandur.org/sqlc)
-   `sqlc.narg()` does not have a shorthand like `@` which is available for `sqlc.arg()`
-   If you're using `pgx/v5`, you probably want `emit_pointers_for_null_types: true` in sqlc config. This makes sure that generated struct fields can be set to null, (in many cases we want to pass NULL to the query)
-   sqlc and pgx/v5
    -   [libpq - Go - Correct way of using pgtypes - Stack Overflow](https://stackoverflow.com/questions/77354445/go-correct-way-of-using-pgtypes)
    -   <https://github.com/sqlc-dev/sqlc/discussions/1332>
    -   <https://github.com/sqlc-dev/sqlc/issues/819>


#### Postgres Gotchas {#postgres-gotchas}

-   [PostgreSQL]({{< relref "20221102123302-postgresql.md" >}}) `DEFAULT` is for when you don't provide a column value in `INSERT` statement. If you provide `NULL` as a value it'll be considered as a value and `DEFAULT` [won't apply](https://stackoverflow.com/questions/73585075/why-is-a-non-null-postgres-column-with-default-throwing-a-constraint-error).


## Go Performance {#go-performance}

-   [Boost application performance with profile guided optimization Michael Pratt, Google - YouTube](https://www.youtube.com/watch?v=0GkRJQ1aUOI)


### Garbage Collection {#garbage-collection}

> `Base heap size` is like the "starting point" memory usage when your program has loaded and initialized, but before it starts doing its main work. Think of it as the program's "idle" memory state.
>
> In Go specifically:
>
> -   It's dynamically determined based on what your program needs at startup
> -   Can vary between runs of the same program
> -   Affected by factors like OS memory layout, system state, and program inputs
> -   Used by Go's garbage collector as a reference point (GC typically allows heap to grow to 2x this size)

See [Garbage collection]({{< relref "20221101213015-garbage_collection.md" >}})

-   By default, Go GC allows the heap to grow up to `2x` its current size before triggering garbage collection
-   Example case
    -   Allocated Mem for executable: 250M
    -   Base heap: 170MB
    -   Potential growth allowed: up to 340MB (2 × 170MB)
    -   Available memory: only 80MB (250-170)
    -   Now the GC won't kick in unless we reach 340M, but we have only allocated 250.
    -   In this case, we can set `GOMEMLIMIT=200MiB`, which will trigger the GC at 200 instead of waiting for the 2x number.


## Template (base-go) {#template--base-go}


### About the template {#about-the-template}


#### Why this template? {#why-this-template}

-   Remove friction of setup of new project
-   Remove friction of writing the initial tests
-   Suitable for: Basic starter, CLI stuff

<!--list-separator-->

-  Improving the template

    -   <https://github.com/sethvargo/go-envconfig#Extension>
    -   <https://github.com/knadh/koanf>


#### Project layout {#project-layout}

-   Inspired by [this layout](https://xeiaso.net/blog/within-go-repo-layout-2020-09-07).
-   Essentials
    -   `cmd/` : executable commands
    -   `docs/` : human readable documentation
    -   `internal/` : code not intended to be used by others
        -   Contains code that others(other things inside the repo aswell outside) shouldn't consume.
        -   It isolates things in a way that files under the same import path can use it, exposing it is out of question. (??)
    -   `scripts/` : any scripts needed for meta-operations
-   Additional
    -   `api/` : OpenAPI/Swagger specs, JSON schema files, protocol definition files.
    -   `configs/` : Configuration file templates or default configs.
    -   `tests/` : Integration tests w data etc. Otherwise, test code lives in the same dir that its code is written in.
    -   `tools/` : Supporting tools for this project.


### Style suggestions and other notes on Go {#style-suggestions-and-other-notes-on-go}


#### Workflow {#workflow}

-   Running tests in watch mode w gosumtest
-   Using go run instead of go build (use with entr): eg. `git-entr go run main.go --some-flag`

<!--list-separator-->

-  Debugging (dlv)

    -   Usually use `dlv test` when you have a test file if you don't have a `main` func.
        -   You cd into the directory where the test is and then
            -   `dlv test -- -test.v` or  simply  `dlv test`
    -   `funcs` : lists all functions. `funcs [some_func]` filters
    -   setting breakpoints
        -   `break [func_name]`
    -   Location specifiers: <https://github.com/go-delve/delve/blob/master/Documentation/cli/locspec.md>
    -   Use `p` to print symbols etc.

<!--list-separator-->

-  Logging

    -   Question: Is it okay to mix slog and log in same package? Eg. in some cases i'd like to avoid slog+osExit and simply use log.Fatal
    -   slog doesn't pass values by map unlike say logurus, which makes this a little bit weird but passing maps [has performance implications](https://news.ycombinator.com/item?id=37224651) but you could use attrs if you want.
    -   [Opinions](https://dave.cheney.net/2015/11/05/lets-talk-about-logging) on logging levels
        -   My opinion
            -   I think when using structured logging, using these levels has some merit unlike what the author suggests. Color coding, easy filtering etc.
        -   Warning: It’s either an informational message, or an error condition. (prefer not using)
        -   Fatal: In golang, it's similar to panic. Better to avoid it only. (prefer not using)
        -   Error: There's no point in logging the error, either handle it or pass it up the stack. (prefer not using)


#### Basics {#basics}

-   [Practical Go: Real world advice for writing maintainable Go programs](https://dave.cheney.net/practical-go/presentations/gophercon-singapore-2019.html#_guiding_principles)
-   Naming &amp; Comments
    -   Overall Docs should answer **why** not **how**, code is how, variables are code
    -   Variable &amp; Constants
        -   Name: Should define its purpose(How). Do no mention the type in the name.
        -   Comment: Should describe the contents(Why) not the purpose(How)
    -   Getter&amp;setters: `Owner` instead of `GetOwner`, `SetOwner` is fine.
    -   Interface names have a `-er`
        -   If methods of interface has name such as Read, Write, Close, Flush, String, try using the canonical signatures.
        -   If the functionality of a method is same as provided by std lib, keep name same. Eg. If method prints sring representation, call it `String` instead of `ToString`
    -   Prefer single words for methods, interfaces, and packages.
-   Global variables become an invisible parameter to every function in your program!
-   Using `Must` as a prefix for function or method names to indicate that the operation is expected to `succeed` or `panic`

<!--list-separator-->

-  Organizing files

    -   All Go code is organized into packages. And we organize code and types by their functional responsibilities.
    -   Keep things close
        -   Keep types close to source, pref. in top of the file.
        -   Code should be as close to where it's used as possible. It might be tempting to put things into `repo-root/internal` but if it makes better sense, put it close to the source, maybe in its own `/internal`.

<!--list-separator-->

-  About `main`

    -   3 things: `package main`, `main()` and `main.go`
    -   Executable program you need an entry point
        -   `package main` + `main()` func is the entry point
    -   The file with the `main()` inside the package `main`, is conventionally named `main.go`. But can be called anything else. But good to follow the convention.
    -   i.e. Have a file(that we want to create an executable out of) inside a directory, name it `main.go` + `package main` + `main()` func. This will give us an executable when go build is run on it.
    -   `main` packages are not importable, so don't export stuff from it.
    -   If your project is just a package and not an executable, it doesn't need a `main()`, hence doesn't need a `main` package at all.

<!--list-separator-->

-  About `init()`

    -   Special function that is executed before `main()`, usually to perform any initialization tasks
    -   Can be defined in any package, multiple such functions can be defined in the same package
    -   Nothing related to being an executable unlike `main()`


#### Packages in Go {#packages-in-go}

<!--list-separator-->

-  Creating packages

    -   Go only allows one package per directory
    -   Package Name/Path
        -   What it provides, not what it contains.
        -   No plurals for package name. don’t name a package httputils, name it httputil
        -   Avoid overly broad package names like “common” and “util”.
    -   Enforce vanity URLs. It ensures this package can only be imported via the mentioned path, even if the other url is serving it.
        ```go
        package datastore // import "cloud.google.com/go/datastore"
        ```

<!--list-separator-->

-  Exposing packages

    ```text
    // from xeiaso
    repo-root
    ├── cmd
    │   ├── paperwork
    │   │   ├── create // exposed to other parts of the module and outside
    │   │   │   └── create.go
    │   │   └── main.go
    │   ├── hospital // not exposed cuz internal
    │   │   ├── internal
    │   │   │   └── operate.go
    │   │   └── main.go
    │   └── integrator // not exposed
    │       ├── integrate.go
    │       └── main.go
    ├── internal // not exposed
    │   └── log_manipulate.go
    └── web // exposed to other parts of the module and outside
        ├── error.go
        └── instrument.go
    ```

    -   Things you don't want to expose
        -   Only internal use : `/internal` (subdirectories can have their own `/internal`)
        -   Other things with `main.go` don't get exposed as it's typically used as an entry point for executable programs.
    -   Things you want to expose
        -   If `web` is used all over your package. (`/repo-root/web`)
        -   From subdirectories/subpackage, close to the code. (`repo-root/cmd/paperwork/create`)
        -   If exposing a package to users, avoid exposing your custom repository structure to your users. i.e Avoid having src/, pkg/ sections in your import paths. So stick to the two points above^

<!--list-separator-->

-  Vendoring

    -   Why vendor?
        -   I sometimes work offline, so vendoring is important for me
        -   Helps to ensure that all files used for build are in a single file tree.
        -   No network access we can build stuff always (we supposed to push the vendor to vcs)
    -   Default behavior is, if `vendor/` directory is present, the go command acts as if `-mod=vendor` otherwise `-mod=readonly`. I think sane defaults.

    <!--list-separator-->

    -  module cache

        -   When `-mod=mod` (This is what `go get` and `go mod tidy` does, doesn't need the flag)
        -   Downloaded `modules` are stored in `GOMODCACHE` and made `read-only`. This cache may be shared by multiple Go projects developed on the same machine.

    <!--list-separator-->

    -  vendor

        -   When `-mod=vendor`, go command will use the `vendor/` directory
        -   Will **not** use the network or the `module cache`
        -   Useful things to know about vendoring
            -   Local changes should not be made to vendored packages. Workspaces can probably help here.
            -   go mod vendor omits go.mod and go.sum files for vendored dependencies
            -   go mod vendor records the go version for each deps in vendor/modules.txt
            -   `go get, go mod download, go mod tidy` will bypass vendor directory and download stuff as expected


#### Testing {#testing}

-   Test code usually lives in the same dir as the code with `<file>_test.go`
-   `fmt.X` work inside tests but it's not supposed to be used there, also it'll format itself weird in the output. For logging in tests, use `t.Log` etc.
-   Assertion are not popular in go and I do not plan to use them, but if I need, there's  [testify](https://github.com/stretchr/testify).
-   You don't want to test private functions, those are implementation details. Better focus on testing the behavior.
-   If the test has &gt; 3 mocks, might be time to reconsider code

<!--list-separator-->

-  Additional testing helper packages

    -   unit tests &amp; mocking : Go's testing framework and dependency injection via interfaces
    -   Acceptance tests: Black box test/Functional tests
        -   These are usually separate packages or somthing that run against the running shit
        -   Usually great for working w legacy codebase or unknown ones
    -   github.com/approvals/go-approval-tests : For goldens


#### HTTP related {#http-related}

<!--list-separator-->

-  Service lifecycle

    -   [Waitgroups](https://medium.com/@yardenlaif/go-sync-or-go-home-errgroup-f91a0ee72d3f), errgroup or oklog/run.
    -   The later 2 are alternatives [trying to](https://github.com/oklog/run/issues/9) improve waitgroup's interface. Choose based on preference.

<!--list-separator-->

-  Routers

    `mux` is short for Multiplexer

    -   `http.ServeMux`
        -   Good to go with in most cases, but doesn't support variables in URL in which case you might consider something else
        -   Avoid using `http.DefaultServeMux`; any package you import can have access to it, eg. if anything imports `net/http/pprof`, clients will be able to get CPU profiles. Instead instantiate an `http.ServeMux` yourself and set it as the `Server.Handler`.
        -   A metric you'll want to monitor is the number of open file descriptors when dealing with webservers. One can use `Server.ConnState` hook to get more detailed metrics of what stage the connections are in.
    -   `go-chi/chi`
        -   for anything else go w chi
    -   Use [unrolled/secure](https://github.com/unrolled/secure) for security headers
    -   Additional notes
        -   Parsing body
            -   [How to Parse a JSON Request Body in Go – Alex Edwards](https://www.alexedwards.net/blog/how-to-properly-parse-a-json-request-body)
            -   <https://gist.github.com/aodin/9493190>
            -   <https://ahmet.im/blog/golang-json-decoder-pitfalls/> (deprecated)
        -   Sending response
        -   Routing techniques
            -   [Different approaches to HTTP routing in Go](https://benhoyt.com/writings/go-routing/)
            -   [Better HTTP server routing in Go 1.22 - Eli Bendersky's website](https://eli.thegreenplace.net/2023/better-http-server-routing-in-go-122/)
        -   Middleware
            -   [Making and Using HTTP Middleware – Alex Edwards](https://www.alexedwards.net/blog/making-and-using-middleware)
        -   Management
            -   [How I write HTTP services after eight years by Mat Ryer - PACE.](https://pace.dev/blog/2018/05/09/how-I-write-http-services-after-eight-years.html)
            -   <https://twitter.com/matryer/status/1445013230858952705>
            -   <https://www.reddit.com/r/golang/comments/sk05z2/how_i_write_http_services_after_eight_years/>

<!--list-separator-->

-  Responses

    -   We need to set `w.Header()` before calling `w.WriteHeader`
        -   first `w.Header().Set("Content-Type", "application/octet-stream")`
        -   then `w.WriteHeader(http.StatusOK)`
        -   otherwise you are making change after headers were written to the response and it will have no effect.


#### Databases {#databases}

-   I've written something about sqlite drivers in my wiki
-   Overall `pgx` + `sqlc` can be a good combination
    -   Transactions: [Is there a way for sqlc to generate code that can use pgxpool](https://stackoverflow.com/questions/76848733/is-there-a-way-for-sqlc-to-generate-code-that-can-use-pgxpool)
        -   Official docs has incomplete example
            -   <https://github.com/sqlc-dev/sqlc/blob/v1.14.0/docs/howto/transactions.md>
            -   <https://github.com/sqlc-dev/sqlc/blob/main/docs/howto/transactions.md>

<!--list-separator-->

-  Interface

    -   These interfaces do need a driver to work with
    -   `database/sql`
        -   See [Go database/sql tutorial](http://go-database-sql.org/)
        -   Basic usage
            -   Write a query, pass in the necessary arguments, and scan the results back into fields.
            -   Programmers are responsible for explicitly specifying the mapping between a SQL field and its value
        -   `sqlx`
            -   Extensions on go's standard database/sql library. (superset of `database/sql`) Eg. allows you to avoid manual column &lt;-&gt; field mapping etc.
            -   `sqlx` work only with the standard interface and not the native interface of `pgx`. So `sqlx` can be used with `pgx` with stdlib compatibility.
    -   ORMs
        -   [Object–relational impedance mismatch - Wikipedia](https://en.wikipedia.org/wiki/Object%E2%80%93relational_impedance_mismatch)
        -   <https://gorm.io/>

<!--list-separator-->

-  Drivers

    -   `pgx` (for postgres)
        -   If needed, it still can be used with [database/sql](https://github.com/jackc/pgx#choosing-between-the-pgx-and-databasesql-interfaces), [sqlc](https://github.com/sqlc-dev/sqlc/issues/1823), [sqlx](https://stackoverflow.com/questions/74348652/what-driver-name-do-i-use-to-connect-go-sqlx-to-postgres-using-the-pgx-driver) etc. But usually, if you're only dealing with postgres, you don't really need these additional layers. Simply `pgx`'s native interface, it can handle most things.
        -   `pgx`'s native interface works with [scany](https://github.com/georgysavva/scany)
        -   It has postgree specific optimizations that are impossible in the standard driver. (for example support for Native Postgres types: arrays, json etc)
        -   Alternatives are `lib/pq` etc. but `pgx` is good.

<!--list-separator-->

-  SQL query builders/code generators/mappers

    -   These basically convert go's syntax into pure SQL.
    -   Example: [squirrel](https://github.com/Masterminds/squirrel), [jet](https://github.com/go-jet/jet)(preferred), [sqlboiler](https://github.com/volatiletech/sqlboiler#getting-started)
    -   `sqlc`
        -   It's NOT a go package, it's a cli tool
        -   From SQL -&gt; Go code
        -   See [Compile SQL queries to type-safe Go](https://conroy.org/introducing-sqlc)
        -   See [How We Went All In on sqlc/pgx for Postgres + Go](https://brandur.org/sqlc)
        -   Works [with pgx](https://docs.sqlc.dev/en/stable/guides/using-go-and-pgx.html)
        -   It does not use struct tags, hand-written mapper functions, unnecessary reflection etc.
        -   It's the opposite of sql query builders
        -   It generates type-safe code for your raw SQL schema and queries.

<!--list-separator-->

-  Transaction and Request cancellation

    -   See [How to work with Postgres in Go. Using Postgres from Golang](https://medium.com/avitotech/how-to-work-with-postgres-in-go-bad2dabd13e4)

<!--list-separator-->

-  Pooling for postgres

    -   See [Application side vs Server side](https://www.reddit.com/r/PostgreSQL/comments/p9vwun/pgbouncer_vs_application_side_pooler/)

    <!--list-separator-->

    -  Why pgxpool?

        -   Usually it's preferred to go with server side pooling than to even worry about client side pooling.
        -   But if you're using `pgx` in a concurrent application, eg. webserver where each web session will create a new database connection then you must you [pgxpool](https://pkg.go.dev/github.com/jackc/pgx/v5/pgxpool) [whether](https://github.com/jackc/pgx/issues/970) or not you're using `pgbouncer` on the [server side](https://github.com/jackc/pgx/discussions/1784) because pgx.conn by itself is not threadsafe, i.e multiple goroutines cannot safely access it.
        -   With pgxpool is you can have long [standing connections](https://github.com/jackc/pgx/issues/1780) with db and pgxpool also tries to restablish connections if they are closed due to environment factors. You don't get it with plain `pgx.Conn`
        -   By default pgx automatically uses prepared statements. Prepared statements are incompaptible with PgBouncer. This can be disabled by setting a different QueryExecMode in ConnConfig.DefaultQueryExecMode.
            -   This has changed! See [Prepared Statements in Transaction Mode for... | Crunchy Data Blog](https://www.crunchydata.com/blog/prepared-statements-in-transaction-mode-for-pgbouncer#how-much-faster-are-prepared-statements)
            -   Also see `PreferSimpleProtocol` (v4)


## Patterns {#patterns}

See [Design Patterns]({{< relref "20221125204047-design_patterns.md" >}})

-   Inorder processing : [blog/programming/GoAndPromisesPattern](https://utcc.utoronto.ca/~cks/space/blog/programming/GoAndPromisesPattern)


## Resources and Links {#resources-and-links}


### Go and sqlite {#go-and-sqlite}

> -   have a dedicated object for writing to the database, and run db.SetMaxOpenConns(1) on it. I learned the hard way that if I don’t do this then I’ll get SQLITE_BUSY errors from two threads trying to write to the db at the same time.
> -   if I want to make reads faster, I could have 2 separate db objects, one for writing and one for reading

-   See [sqlite]({{< relref "20230702184501-sqlite.md" >}}) also see [Go and SQLite in the Cloud](https://www.golang.dk/articles/go-and-sqlite-in-the-cloud)
-   [mattn/go-sqlite3](https://github.com/mattn/go-sqlite3) : Uses [cgo](https://github.com/mattn/go-sqlite3/commit/2df077b74c66723d9b44d01c8db88e74191bdd0e) (most commonly used). But cgo takes os thread.
    -   See [this link](https://github.com/mattn/go-sqlite3/issues/1022#issuecomment-1067353980) for some usage tips
-   [cznic/sqlite](https://gitlab.com/cznic/sqlite) : Somehow [translates](https://gitlab.com/cznic/ccgo) C code to Go.
-   [ncruces/go-sqlite3](https://github.com/ncruces/go-sqlite3) : wraps a WASM build of SQLite, and uses [wazero](https://wazero.io/) to provide cgo-free SQLite bindings.
-   <https://github.com/cvilsmeier/go-sqlite-bench>
    -   ncruces: [Show HN: My Go SQLite driver did poorly on a benchmark](https://news.ycombinator.com/item?id=38650570)
-   ORM
    -   [go-gorm/sqlite](https://github.com/go-gorm/sqlite): GORM sqlite driver
    -   [glebarez/sqlite](https://github.com/glebarez/sqlite/): The pure-Go SQLite driver for GORM (fork)
    -   [glebarez/go-sqlite:](https://github.com/glebarez/go-sqlite) pure-Go SQLite driver for Go (SQLite embedded)


### Performance {#performance}

-   [CPU throttling for containerized Go applications explained - Kanishk Singh](https://kanishk.io/posts/cpu-throttling-in-containerized-go-apps/)


### Concurrency stuff 🌟 {#concurrency-stuff}

-   <https://victoriametrics.com/blog/go-io-reader-writer/?s=35>
-   <https://victoriametrics.com/blog/go-sync-mutex/index.html>
