+++
title = "Golang"
author = ["Hrishikesh Barman"]
draft = false
+++

tags
: [Programming Languages]({{< relref "20221101220306-programming_languages.md" >}})


## Installation {#installation}

-   Do not want ~/go
-   You no longer need to set your GOPATH.
-   I put gopath on a ramdisk, because its an cacge which is polluted fast with old versions. GOBIN is set to ~/.local/bin, so the installed go binaries are static and in the path.
    ```shell
    export GOPATH=~/Projects/go
    ```


## Packages and Modules {#packages-and-modules}


### Module {#module}

-   A `module` is a collection of `packages` stored in a file tree with a go.mod file at its root.
-   The tree(`module`) with branches(`packages`) and leafs(`*.go` files) growing on branches.
-   `packages` sharing the same lifecycle(version number) are bundled into a `module`.
-   <https://go.dev/ref/mod>


### Packages {#packages}

-   Each directory that has Go source code inside of a `module`, possibly including the root directory, is a `package`.
-   Go does not have a central package authority in the vein of `npm` or `crates.io`
-   Go's package management system uses the `package` name to learn how to download the package. This is why usually the


#### Example of a package {#example-of-a-package}

```shell
.
├── example.go
├── go.mod
└── util
    └── util.go
$ cat go.mod
module github.com/example/example
go 1.20
```

-   This module contains two packages
    -   module root : `import "github.com/example/example"`
    -   the `util` directory : `import "github.com/example/example/util"`
-   In the case of the root module


### Standard Library {#standard-library}

-   You can find these in the go source tree
-   See [Standard library - Go Packages](https://pkg.go.dev/std)


### Subrepos {#subrepos}

-   Things inside `/x`
-   Packages are part of the Go Project but outside the main Go tree.
-   See [Sub-repositories - Go Packages](https://pkg.go.dev/golang.org/x)


### Project structure {#project-structure}

-   Multimodules monorepos is advanced usecase
-   Monomodule multipackage is the structure most of the time
-   [GitHub - golang-standards/project-layout: Standard Go Project Layout](https://github.com/golang-standards/project-layout)
-   [How do I Structure my Go Project? | Mark Wolfe's Blog](https://www.wolfe.id.au/2020/03/10/how-do-i-structure-my-go-project/)


### Imports {#imports}

-   `./…`: An import path is a pattern if it includes one or more "..." wildcards, each of which can match any string. Example: `x/...` matches `x` as well as `x`'s subdirectories.


### Proxy {#proxy}

-   What's the lag between pushing to github and go install $name@latest getting the latest commit?
-   go uses a proxy, That proxy regularly updates from the original repository
-   try `GOPROXY=direct` go install $name@latest
-   <https://goproxy.io/>
-   <https://proxy.golang.org/>


## Building and Compiling {#building-and-compiling}


### Syscalls {#syscalls}


#### How does go make syscalls? {#how-does-go-make-syscalls}

-   [Differs](https://www.reddit.com/r/rust/comments/n8iq0f/how_does_the_rust_standard_library_work/) by [Operating](https://www.reddit.com/r/golang/comments/lapzam/go_116_will_make_system_calls_through_libc_on/) [system](https://groups.google.com/g/golang-nuts/c/uX8eUeyuuAY)
-   In Linux, because it has a [stable ABI](https://stackoverflow.com/questions/55735864/how-does-go-make-system-calls), it makes the syscalls directly skipping `libc`. w Linux, the kernel to userspace interface is stable(which syscalls use), but the [in kernel interfaces are not stable](https://github.com/torvalds/linux/blob/master/Documentation/process/stable-api-nonsense.rst).
-   Enabling or disabling `CGO` has nothing to do with whether or not go syscall goes via `libc`, the C code used via `CGO` ofcourse will use `libc`.
-   Go does create wrappers around some syscalls (TODO: Need to dig into this)
-   Support for different syscalls in different OS is incremental. Eg. If `X` syscall is available in OS `A` and `B`. Go might have support for `X` only in `A` as of the moment.


#### Places where go handles syscalls {#places-where-go-handles-syscalls}

-   Try `fd syscall -t` on the go source tree.
-   [/syscall](https://pkg.go.dev/syscall@go1.20.2) : [Frozen](https://www.reddit.com/r/golang/comments/jt1qfm/syscall_package_deprecated_question/), except for changes needed to maintain the core repository.
-   [/internal/syscall](https://pkg.go.dev/internal/syscall@go1.20.2) : internal
-   [/runtime/internal/syscall](https://pkg.go.dev/runtime/internal/syscall) : internal, [some details](https://utcc.utoronto.ca/~cks/space/blog/programming/GoSchedulerAndSyscalls)
-   [/x/sys](https://pkg.go.dev/golang.org/x/sys)
    -   This is where new stuff goes and should be used by callers
    -   Contains 3 packages to hold their syscall implementations(Unix, Windows and Plan 9)
    -   Has the wrapper creation libraries such as [mkwinsyscall.go](https://cs.opensource.google/go/x/sys/+/refs/tags/v0.6.0:windows/mkwinsyscall/mkwinsyscall.go) and [mksyscall.go](https://cs.opensource.google/go/x/sys/+/refs/tags/v0.6.0:unix/mksyscall.go)


### Portability {#portability}

-   syscalls are not portable by nature, they are specific to the system. We need to add a build tag for the ARCH and OS that syscall invocation is valid for.


### Dynamic and Static Linking {#dynamic-and-static-linking}


#### Static linking {#static-linking}

<!--list-separator-->

-  Directly

    -   [Matt Turner - Statically Linking Go in 2022](https://mt165.co.uk/blog/static-link-go/)

<!--list-separator-->

-  musl

    -   [Statically compiled Go programs, always, even with cgo, using musl](https://honnef.co/articles/statically-compiled-go-programs-always-even-with-cgo-using-musl/)
    -   You can also statically link with musl, but note that musl lacks features that people might want to use non-pure Go in the first place. For example, musl does't support arbitrary name resolvers, e.g. no LDAP support; it only supports DNS, just like the pure Go net package.
    -   On the other hand musl does support os/user.

<!--list-separator-->

-  glibc

    -   **STATIC LINKING OF GLIBC IS DISCOURAGED**
    -   It [makes extensive](https://stackoverflow.com/questions/57476533/why-is-statically-linking-glibc-discouraged) internal use of `dlopen`, to load [nsswitch]({{< relref "20230228000520-nsswitch.md" >}}) modules and `iconv` [conversions](https://man7.org/tlpi/api_changes/index.html).


#### Dynamic linking {#dynamic-linking}

<!--list-separator-->

-  glibc versioning

    -   [GoAndGlibcVersioning](https://utcc.utoronto.ca/~cks/space/blog/programming/GoAndGlibcVersioning)

<!--list-separator-->

-  Other

    -   [Dynamic linking](https://drewdevault.com/dynlib.html)
    -   [A dynamic linking dependency problem in Golang](https://www.sobyte.net/post/2022-05/golang-dynamic-linking/)


### CGO {#cgo}

`CGO` is essentially utilizing C api calls to shared libraries exporting C interface. It is a [tradeoff](https://dave.cheney.net/2016/01/18/cgo-is-not-go).


#### Using CGO {#using-cgo}

-   `CGO_ENABLED=1`
-   Some things are only available as C libraries, re-implementing that in Go would be costly.
-   CGO is also used in some parts of standard library. Eg. ([net](https://pkg.go.dev/net#hdr-Name_Resolution) and os/user). It's not a strict requirement though, you can use these packages w/o CGO and they'll use stripped down version written in Go. But if you want the full thing, you have no other option than to enable `CGO`


#### Without using CGO {#without-using-cgo}

-   `CGO_ENABLED=0`
-   [GitHub - ebitengine/purego](https://github.com/ebitengine/purego)
-   [Introducing wazero from Tetrate - Tetrate](https://tetrate.io/blog/introducing-wazero-from-tetrate/?hss_channel=tw-998918265177952259)


### Cross Compilation {#cross-compilation}


#### General cross compilation ideas {#general-cross-compilation-ideas}

-   Cross compiler: Compiler capable of creating executable code for a platform other than the one on which the compiler is running on.
-   Levels (can be one or many)
    -   Architecture: MIPS/x86/arm
    -   Vendors: Mostly `unknown`
    -   OS: FreeBSD/Linux
    -   ABI: msul libc/glibc
-   `sysroot`: Directory which is considered to be the root directory for the purpose of locating headers and libraries.
-   `toolchain`: The set of compiler, linker, shared libs, any tools needed to produce the executable for the target.


#### Cross compilation in Golang {#cross-compilation-in-golang}

-   Unless you're using a native cross compiler(eg. Clang, Golang Compiler), to cross-compile a program, you need to separately build and install a complete gcc+binutils toolchain for every individual arch that you want to target.
-   Which Go this is easy(cross compiler out of the box) + dependencies ensured to support.


#### Cross compilation and CGO {#cross-compilation-and-cgo}

`CGO` allows us to access C libraries in the system we're building/compiling on. It has no idea about C libraries of other systems. So mostly CGO is disabled by default if cross-compiling. However, if you need to cross-compile go code with `CGO`, you need a cross-compiling C compiler for the target machine. It can be done but it is a bit of PITA.

<!--list-separator-->

-  Using Zig

    -   See [this](https://zig.news/kristoff/building-sqlite-with-cgo-for-every-os-4cic) and [this](https://lucor.dev/post/cross-compile-golang-fyne-project-using-zig/)

    <!--listend-->

    ```shell
    CGO_ENABLED=1 GOOS=linux GOARCH=amd64 CC="zig cc -target x86_64-linux" CXX="zig c++ -target x86_64-linux" go build --tags extended
    ```

<!--list-separator-->

-  Naively Compiling

    -   Compile in an actual machine w of target directly
    -   You can [use chroot](https://blog.surgut.co.uk/2014/06/cross-compile-go-code-including-cgo.html)
    -   You can [use](https://dh1tw.de/2019/12/cross-compiling-golang-cgo-projects/) [containers](https://goreleaser.com/cookbooks/cgo-and-crosscompiling/)
    -   Other [stuff](https://github.com/FiloSottile/homebrew-musl-cross)


## Language topics {#language-topics}


### Language components {#language-components}

-   Go runtime
-   Go scheduler
-   Go GC: See [Garbage collection]({{< relref "20221101213015-garbage_collection.md" >}})


### Pointers {#pointers}

-   There's no pointer arithmetic in go
-   Go guarantees that, thing being pointed to will continue to be valid for the lifetime of the pointer.
    ```go
    func f() *int {
            i := 1
            return &i
    } // Go will arrange memory to store i after f returns.
    ```


### Context {#context}

-   It's not possible for a function that takes a `context.Context` and cancel it.
-   All it could do is `newCtx, cancel := context.WithCancel(origCtx)`.
-   In that case, when `cancel()` is called `newCtx` will be canceled, but `origCtx` will not.
-   `newCtx` will have access to the same values as `origCtx` and will be canceled either when `cancel()` is called or `origCtx` is canceled
-   More on context: [Break The Golang Context Chain » Rodaine](https://rodaine.com/2020/07/break-context-cancellation-chain/)
-   Even more: [Chris's Wiki blog/programming/GoContextValueMistake](https://utcc.utoronto.ca/~cks/space/blog/programming/GoContextValueMistake)


### Groutines {#groutines}


## Random Guidelines {#random-guidelines}


### Names and Comments {#names-and-comments}

-   Variable/Constant name: Should describe its purpose.
-   Comments on variables and constants: Should describe their contents not their purpose.
-   Package Name: What it provides, not what it contains.


### Slice {#slice}

-   Assign nil to a slice (Change this to codeblock TODO)
    -   zero len
    -   zero cap
    -   no longer point an underlying array


### Variables {#variables}

-   Global variables become an invisible parameter to every function in your program!


### Maps {#maps}

-   Go Maps are hashmap. O(1) ACR, O(n) WCR
-   A Map value is a pointer to a `runtime.hmap` structure.
-   Since it's a pointer, it should be written as `*map[int]int` instead of `map[int]int`. Go team changed this historically cuz it was [confusing anyway](https://dave.cheney.net/2017/04/30/if-a-map-isnt-a-reference-variable-what-is-it).
-   They are sometimes used across goroutines to do shared state.
-   Maps are **not goroutine safe**, Use `sync.Mutex`, `sync.RWMutex` etc. to ensure things are properly synchronized.
-   Maps change it's structure
    -   When you insert or delete entries
    -   The map may need to rebalance itself to retain its O(1) guarantee
-   What the compiler does when you use map
    ```go
    v := m["key"]     // → runtime.mapaccess1(m, ”key", &v)
    v, ok := m["key"] // → runtime.mapaccess2(m, ”key”, &v, &ok)
    m["key"] = 9001   // → runtime.mapinsert(m, ”key", 9001)
    delete(m, "key")  // → runtime.mapdelete(m, “key”)
    ```


## Resources and Links {#resources-and-links}

-   [go language philosphy thorugh proverbs](https://ultrasaurus.com/2016/07/go-language-philosphy-thorugh-proverbs/)
-   [Go: Should I Use a Pointer instead of a Copy of my Struct?](https://medium.com/a-journey-with-go/go-should-i-use-a-pointer-instead-of-a-copy-of-my-struct-44b43b104963)
-   [The Within Go Repo Layout - Xe Iaso](https://christine.website/blog/within-go-repo-layout-2020-09-07)
-   [A few bytes here, a few there, pretty soon you’re talking real memory | Dave Cheney](https://dave.cheney.net/2021/01/05/a-few-bytes-here-a-few-there-pretty-soon-youre-talking-real-memory)
-   [Practical Go: Real world advice for writing maintainable Go programs](https://dave.cheney.net/practical-go/presentations/gophercon-singapore-2019.html)
