+++
title = "Database"
author = ["Hrishikesh Barman"]
draft = false
+++

tags
: [SQL]({{< relref "20230217190123-sql.md" >}}), [Distributed Systems]({{< relref "20221102130004-distributed_systems.md" >}}), [PostgreSQL]({{< relref "20221102123302-postgresql.md" >}})


## Database types {#database-types}

{{< figure src="./images/sql-vs-nosql-cheatsheet.webp" >}}


### Based on Relational(SQL) v/s Non-relational(NoSQL) {#based-on-relational--sql--v-s-non-relational--nosql}

{{< figure src="/ox-hugo/20221102123145-database-357404598.png" >}}


#### Relational {#relational}

-   Schema
-   [PostgreSQL]({{< relref "20221102123302-postgresql.md" >}}), MySQL etc


#### Non-Relational / NoSQL {#non-relational-nosql}

-   Schemaless
-   This should have been named NoRDBMS instead because it's not no sql that is. Infact, no-sql dbs can support sql like queries etc.


### Based on [CAP]({{< relref "20221102130004-distributed_systems.md#cap" >}}) {#based-on-cap--20221102130004-distributed-systems-dot-md}

{{< figure src="/ox-hugo/20221102123145-database-267730290.png" >}}

-   While most Relational DBs guarantee ACID, NoSQL DBs give [you BASE](https://dl.acm.org/doi/10.1145/1394127.1394128)


### Based on Data model {#based-on-data-model}

These data models can be implemented in both Relational and Non-Relational types. Eg. [PostgreSQL]({{< relref "20221102123302-postgresql.md" >}}) can also be turned into column store/json data store with indexes and extensions etc. But database built for specific data models would most probably be the ideal solution rather than make up for it w extensions etc.
![](/ox-hugo/20221102123145-database-813312395.png)
Eg. KV, Graph, Document/Object, Column-family, Array/Matrix/Vectors etc.


#### KV {#kv}

-   Redis, DynamoDB etc.


#### Document/Object based {#document-object-based}

-   MongoDB, DocumentDB etc.


#### Column {#column}

-   Wide column: `(Partition Key, Cluster Key, Value)`
-   AWS Redshift, [DuckDB](https://news.ycombinator.com/item?id=34741195), Cassandra, Clickhouse, HBase(NoSQL), Scylla
-   Clickhouse is a Column SQL DB while, Scylla is a Column NoSQL DB.
-   Data Warehouse are built on columnar storage, See [Data Engineering]({{< relref "20230405003455-data_engineering.md" >}})


### Based on Query {#based-on-query}

![](/ox-hugo/20221102123145-database-828653387.png)
![](/ox-hugo/20221102123145-database-1967162762.png)


#### OLTP {#oltp}


#### OLAP {#olap}


## Relational Model basics {#relational-model-basics}


### Components {#components}

-   tables = relations
    -   Unordered set that contain the relationship of attributes that represent entities.
    -   Table w `n-ary relation` = Table w n columns
-   attributes = columns (has a type/domain)
-   tuple = row = set of attributes/columns
-   Values
    -   Normally atomic/scalar
    -   `NULL` is a member of every domain if allowed


### Keys {#keys}


#### Primary {#primary}

-   primary key uniquely identifies a single tuple. Some DBMS automatically create primary key.


#### Foreign {#foreign}

-   one-one
-   one-many : we can have an external table


### Data model &amp; Schema {#data-model-and-schema}

A data model is a collection of concepts for describing the data in a database.


## Normalization {#normalization}


### Which one? {#which-one}

-   This really depends on access pattern and usecase
-   But generally go with normalized cuz less space and updates in one place, we can always de-normalize it if required


### Normalized {#normalized}

-   Why normalize? to reduce data redundancy and better `data integrity` through `constraints`.
-   Less storage space, More lookups, Updates in one place
-   We need to JOIN


### De-normalized {#de-normalized}

-   More storage, Less lookups, Updates in many places!


## Partitioning {#partitioning}

-   See [Scaling Databases]({{< relref "20230608143206-scaling_databases.md" >}})
-   A rather general concept and can be applied in many contexts.
-   Partitioning could be
    -   Different database inside MySQL on the same server
    -   Different tables
    -   Different column value in a singular table


### Horizontal/Row based {#horizontal-row-based}

![](/ox-hugo/20230608143206-scaling_databases-673884427.png)
![](/ox-hugo/20230608143206-scaling_databases-1571241611.png)

-   Splitting one table into different tables. Same table structure.


### Vertical/Column based {#vertical-column-based}

-   Splitting one table into different tables. Each table will have a different table structure.
-   This is similar to the idea of **Normalization**
    -   Usually vertical partitioning refers to a physical optimization
    -   Whereas normalization is an optimization on the conceptual level


## on ORMs {#on-orms}

-   ORMs are made for OLTP workloads, not OLAPs
-   [Is ORM still an 'anti pattern'? · getlago/lago Wiki · GitHub](https://github.com/getlago/lago/wiki/Is-ORM-still-an-%27anti-pattern%27%3F)


## ACID {#acid}


### Atomicity {#atomicity}


### Isolation {#isolation}

-   No transaction is affected by any other transaction that is still in progress


### Durability {#durability}

-   When i hit save, things should go to non-volatile shit, so that if system crashes, i can still read the data


### Consistency {#consistency}

-   Understanding Atomicity and Isolation important before understanding Consistency
-   Some sacrifice durability for performance.
