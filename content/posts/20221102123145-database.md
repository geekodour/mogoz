+++
title = "Database"
author = ["Hrishikesh Barman"]
draft = false
+++

tags
: [SQL]({{< relref "20230217190123-sql.md" >}}), [Distributed Systems]({{< relref "20221102130004-distributed_systems.md" >}}), [PostgreSQL]({{< relref "20221102123302-postgresql.md" >}})


## Database types {#database-types}

{{< figure src="./images/sql-vs-nosql-cheatsheet.webp" >}}


### Based on Relational(SQL) v/s Non-relational(NoSQL) {#based-on-relational--sql--v-s-non-relational--nosql}

{{< figure src="/ox-hugo/20221102123145-database-357404598.png" >}}


#### Relational {#relational}

-   Schema
-   [PostgreSQL]({{< relref "20221102123302-postgresql.md" >}}), MySQL etc


#### Non-Relational / NoSQL {#non-relational-nosql}

> -   Access paths
>     -   Relational model allows you to do "point" queries. i.e you can get "any" or "all" of something. Eg. any or all comments, any or all users.
>     -   w Non-relational(usually tree), you need to worry about access path.
>         -   Find any comment? you need to know what post it is attached to.
>     -   Find all comments? you have to traverse all posts to all comments.
>         -   If path changes, you have to go update application logic
> -   Start node
>     -   Finding start nodes is what SQL explicitly excels at.
>     -   Once we do have a start node (a comment, post, user, etc.), a Graph query language is a better fit for application queries than SQL.
>
> Few words by tantaman^

-   Schemaless
-   This should have been named NoRDBMS instead because it's not no sql that is. Infact, no-sql dbs can support sql like queries etc.


### Based on [CAP]({{< relref "20221102130004-distributed_systems.md#cap" >}}) {#based-on-cap--20221102130004-distributed-systems-dot-md}

{{< figure src="/ox-hugo/20221102123145-database-267730290.png" >}}

-   While most Relational DBs guarantee ACID, NoSQL DBs give [you BASE](https://dl.acm.org/doi/10.1145/1394127.1394128)


### Based on Data model {#based-on-data-model}

These data models can be implemented in both Relational and Non-Relational types. Eg. [PostgreSQL]({{< relref "20221102123302-postgresql.md" >}}) can also be turned into column store/json data store with indexes and extensions etc. But database built for specific data models would most probably be the ideal solution rather than make up for it w extensions etc.
![](/ox-hugo/20221102123145-database-813312395.png)
Eg. KV, Graph, Document/Object, Column-family, Array/Matrix/Vectors etc.


#### KV {#kv}

-   Redis, DynamoDB etc.


#### Document/Object based {#document-object-based}

-   MongoDB, DocumentDB etc.


#### Column {#column}

-   Wide column: `(Partition Key, Cluster Key, Value)`
-   AWS Redshift, [DuckDB](https://news.ycombinator.com/item?id=34741195), Cassandra, Clickhouse, HBase(NoSQL), Scylla
-   Clickhouse is a Column SQL DB while, Scylla is a Column NoSQL DB.
-   Data Warehouse are built on columnar storage, See [Data Engineering]({{< relref "20230405003455-data_engineering.md" >}})


### Based on Query {#based-on-query}

![](/ox-hugo/20221102123145-database-828653387.png)
![](/ox-hugo/20221102123145-database-1967162762.png)


#### OLAP {#olap}

-   Analytics workload


#### OLTP {#oltp}

-   Transactional workload


#### Operational {#operational}

> -   "automated interventions in the business"
> -   Think of OLTP workload on a OLAP database

![](/ox-hugo/20221102123145-database-1795534000.png)
![](/ox-hugo/20221102123145-database-996881664.png)
![](/ox-hugo/20221102123145-database-687611546.png)

-   Operational is slightly different from transactional&amp;analytical, somewhere in the middle
-   Usually involves maintenance workloads etc. Sometimes queries need to run on big datasets.
-   Operational workloads have fundamental requirements that are diametrically opposite from the requirements for analytical systems
-   If an operational system goes down for the day, there are people who will either be unable to do their job
-   Similarities with Analytics workload is that both sort of will share SQL queries that are complex, join-heavy, multi-level.
-   Solutions
    -   Reverse ETL (See [Data Engineering]({{< relref "20230405003455-data_engineering.md" >}})) for this purpose
    -   Cache results (but now need to worry about cache invalidation)


## Relational Model basics {#relational-model-basics}


### Components {#components}

-   tables = relations
    -   Unordered set that contain the relationship of attributes that represent entities.
    -   Table w `n-ary relation` = Table w n columns
-   attributes = columns (has a type/domain)
-   tuple = row = set of attributes/columns
-   Values
    -   Normally atomic/scalar
    -   `NULL` is a member of every domain if allowed


### Keys {#keys}


#### Primary {#primary}

-   primary key uniquely identifies a single tuple. Some DBMS automatically create primary key.


#### Foreign {#foreign}

-   one-one
-   one-many : we can have an external table


### Data model &amp; Schema {#data-model-and-schema}

A data model is a collection of concepts for describing the data in a database.


## Modeling of Databases {#modeling-of-databases}


### Normalization {#normalization}


#### Which one? {#which-one}

-   This really depends on access pattern and usecase
-   But generally go with normalized cuz less space and updates in one place, we can always de-normalize it if required


#### Normalized {#normalized}

-   Why normalize? to reduce data redundancy and better `data integrity` through `constraints`.
-   Less storage space, More lookups, Updates in one place
-   We need to JOIN


#### De-normalized {#de-normalized}

-   More storage, Less lookups, Updates in many places!


### Partitioning {#partitioning}

-   See [Scaling Databases]({{< relref "20230608143206-scaling_databases.md" >}})
-   A rather general concept and can be applied in many contexts.
-   Partitioning could be
    -   Different database inside MySQL on the same server
    -   Different tables
    -   Different column value in a singular table


#### Horizontal/Row based {#horizontal-row-based}

![](/ox-hugo/20230608143206-scaling_databases-673884427.png)
![](/ox-hugo/20230608143206-scaling_databases-1571241611.png)

-   Splitting one table into different tables. Same table structure.


#### Vertical/Column based {#vertical-column-based}

-   Splitting one table into different tables. Each table will have a different table structure.
-   This is similar to the idea of **Normalization**
    -   Usually vertical partitioning refers to a physical optimization
    -   Whereas normalization is an optimization on the conceptual level


## Important Features {#important-features}


### Caching {#caching}


#### External {#external}

-   External Materialized views
    -   See [Materialize: An Operational Data Warehouse](https://materialize.com/blog/operational-data-warehouse/)
-   Query caching
    -   See [ReadySet | Same database, (much) faster queries](https://readyset.io/)
    -   [Redis]({{< relref "20230406214230-redis.md" >}}) should also be able to do this?


### Indexes {#indexes}


#### Meta ideas about indexes {#meta-ideas-about-indexes}

-   The order of columns in an index matters for a particular query
    -   order of columns in the query should match how the index was defined


#### Clustered Indexes {#clustered-indexes}


#### Covering Indexes {#covering-indexes}


#### Partial Indexes {#partial-indexes}


#### Index on expression {#index-on-expression}


#### Non-Clustered Indexes {#non-clustered-indexes}


#### COALESCE Index {#coalesce-index}


#### On [uuid]({{< relref "20230801145421-uuid.md" >}}) v4 and Indexes {#on-uuid--20230801145421-uuid-dot-md--v4-and-indexes}

uuidv4 is random and should not be used for indexes because

-   they're random and indexes are meant to be ordered based on the specific implementation
-   If we're adding new items to the index and they're random, we'd need to balance/re-order the index on each insert to the index
-   this causes thrashing which is bad for performance


### Migrations {#migrations}

-   Few comments form HN
    -   rollbacks are bullshit, stop pretending they aren't. They work fine for easy changes, but you can't rollback the hard ones (like deleting a field), and you're better off getting comfortable with forward-only migrations
    -   never expose real tables to an application. Create an "API" schema which contains only views, functions, procedures, and only allow applications to use this schema. This gives you a layer of indirection on the DB side such that you can nearly eliminate the dance of coordinating application changes and database migrations
    -   It isn't possible to atomically deploy both the migration and the application code that uses it. This means if you want to avoid a few seconds/minutes of errors, you need to deploy the migration first in a way that doesn't break existing code, then the application change, and then often a cleanup step to complete the migration in a way that won't break.


### Cursors {#cursors}


### Vacuum {#vacuum}

-   Normal vacuum
-   Auto vacuum
-   Incremental vacuum


### Tables {#tables}

-   Regular tables
-   Temporary tables
-   Virtual tables
    -   A virtual table is an object which does not mirror a table on disk.


#### How table data is stored {#how-table-data-is-stored}

-   InnoDB is similar to SQLite all tables are clustered indexes, if you don't have suitable primary key it creates a hidden one similar to rowid in SQLite.
-   MSSQL and Oracle give you a choice for table storage to either have unordered heaps or ordered b-trees, depending on whether a clustered index is defined.
-   PG only has unordered heaps, indexes are always secondary data structures. PG could really use true clustered indexes as an option.


### Locks {#locks}


#### Exclusive Locks {#exclusive-locks}

-   In some DBs, exclusive locks can be set at the db level reducing the no. locks needed for `transactions`, which can speed up things. But you also loose concurrent writes this way. Just something to be aware of


### Durability {#durability}

-   SQLite only acknowledges a transaction when it is safely persisted to the underlying storage.


## Consistency {#consistency}


### ACID {#acid}


#### Atomicity {#atomicity}


#### Isolation {#isolation}

-   No transaction is affected by any other transaction that is still in progress


#### Durability {#durability}

-   When i hit save, things should go to non-volatile shit, so that if system crashes, i can still read the data


#### Consistency {#consistency}

-   Understanding Atomicity and Isolation important before understanding Consistency
-   Some sacrifice durability for performance.


### Transactionality {#transactionality}

-   [Transactions Are Not Locks (2022) | Hacker News](https://news.ycombinator.com/item?id=37970308)
-   cockroach and SQLite have effectively serializable transactions.
    -   But also, serializable transactions don't catch all bugs either.


### Linearizability {#linearizability}


### Serializability? {#serializability}


## Tooling {#tooling}


### on ORMs {#on-orms}

-   ORMs are made for OLTP workloads, not OLAPs
-   [Is ORM still an 'anti pattern'? · getlago/lago Wiki · GitHub](https://github.com/getlago/lago/wiki/Is-ORM-still-an-%27anti-pattern%27%3F)
