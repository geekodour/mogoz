+++
title = "PostgreSQL"
author = ["Hrishikesh Barman"]
draft = false
+++

tags
: [Database]({{< relref "20221102123145-database.md" >}})


## FAQ {#faq}


### How does Supabase work? {#how-does-supabase-work}

{{< figure src="/ox-hugo/20221102123302-postgresql-808560891.png" >}}

-   Supabase is more of BaaS (Backend-as-a-Service) than a [Database]({{< relref "20221102123145-database.md" >}}) service
-   Every table, view, and stored procedure is automatically mapped to a RESTful API.
-   Supabase uses PostgREST
-   See
    -   [Reddit - Dive into anything](https://www.reddit.com/r/golang/comments/181xupi/golang_with_supabase/)
    -   [The good parts of Supabase - @noahflk](https://noahflk.com/blog/supabase-the-good-parts)


### What's PostgREST? {#what-s-postgrest}

-   Also see [REST / RESTful / REpresentational State Transfer]({{< relref "20230302195820-api_design.md#rest-restful-representational-state-transfer" >}}), PostgREST is not really REST.
-   PostgREST is based on the idea if you are accessing the database as a particular user, [Row Level Security (RLS)](#row-level-security--rls) will ensure that you'll have access to the data you need.
    -   Users need to be authenticated and authorized.
    -   As this is like the backend now, some kind of pool for connections would be needed
-   Its API looks like a mixture of RESTful and GraphQL.


### How to use EXPLAIN? {#how-to-use-explain}

{{< figure src="/ox-hugo/20221102123302-postgresql-1354143187.png" >}}

-   Can give you the cost before hand
-   Can estimate how many rows it'll return etc.


### How to use ANALYZE? {#how-to-use-analyze}

-   It runs the shit that collects the statics that the query planner uses and what we see when we run `EXPLAIN`


### Postgres by default runs in `read committed`, so transactions are not serializable. How is this acceptable? {#postgres-by-default-runs-in-read-committed-so-transactions-are-not-serializable-dot-how-is-this-acceptable}

-   With `read committed`, Query in a transaction
    -   Sees only data committed before the query began;
    -   Never sees uncommitted data
    -   Never sees changes committed by concurrent transactions during the query's execution
-   This is slightly different for writes( See [MVCC]({{< relref "20231116004530-mvcc.md" >}}) )
-   The partial transaction isolation provided by Read Committed mode is adequate for many applications


## Postgres Schema and Database Objects {#postgres-schema-and-database-objects}


### Meaning of schema {#meaning-of-schema}

-   The concept of a schema is not very consistent between DBMSs.
    -   In mysql, it calls schemas databases, and only has one database.
    -   Schemas are the implementation in postgres of the namespace concept. It's a collection of logical structures of data.
-   This is different from the general idea of database schema
-   `SHOW SEARCH_PATH`


### Hierarchy of "things" in postgres {#hierarchy-of-things-in-postgres}

{{< figure src="/ox-hugo/20221102123302-postgresql-2064269945.png" >}}

-   A single machine/host can have multiple `clusters`, clusters run in a `port`
-   A `cluster` can have many `databases`, `roles/users` and more `cluster` level `objects`. i.e `role` and `database` are couples. but `role` keeps cheating, so a single `role` can be the owner of multiple `databases`.
-   Then we have `database` level `objects`
    -   Belonging to some `schema` (namespaced)
        -   Eg. `Tables`, `views`, sequences, functions, procedures, types, domains, etc.
        -   Eg. `Indexes` and `triggers` are always created in the same schema as the table they are for.
    -   Not belonging to some schema (no namespace)
        -   Eg. Extensions
-   There can be `schemas` with the same `name` in different `databases` (but not in the same `database`).
-   `objects` from one `database` cannot interact with `objects` from another one (catalogs are kept separated). Eg. we can't join across two databases. Use `schema` instead.
-   A `database` can have multiple `schemas`


### Understanding usecase of `schema` and `search_path` in postgres {#understanding-usecase-of-schema-and-search-path-in-postgres}

-   Organization
    -   Think of `schema` like directories and database objects as files. You can do without directories but it helps organize.
    -   Eg. In a single database, you can have schemas like `ecommerce`, `auth` etc.
    -   Helpful in dumping, selecting all tables in a schema etc.
-   Access control
    -   This has roots into the usecase where a database has multiple users. In our web application world, we usually have one user accessing it. So we set the `search path` in the [connection string](https://github.com/jackc/pgx/issues/1013).
    -   Grant `privileges` to `roles` at `schema` level, so that all `objects` inside that `schema` will have those access.


#### When to create `schema`, when to create `database`? {#when-to-create-schema-when-to-create-database}

-   If projects/users should be separate and be unaware of each other: `databases`
-   If projects/users are interrelated, should be able to use each other's resources: `schemas`


### search path and schema {#search-path-and-schema}


#### search path {#search-path}

-   When using schema, you need to use "qualified" names. Instead you can use `search path`
-   If `object` is referenced without `schema` qualification, the `search path` is traversed until a matching object is found.
-   `schema path` is a list of path, whichever is found first is used.
    -   The first schema in the `search path` that "exists" is the default location for creating new objects.
    -   That is the reason that by default objects are created in the `public` schema.
-   Eg. follwing shows tables from all schema
    ```nil
      \dt *.*
    ```


#### Builtin schema {#builtin-schema}

-   `public` schema: There's nothing special about the public schema except that it exists by default. It can be dropped, too. It's just is there when you create a new `database`, so if you create `objects` without specifying any schema, it'll go land up in the `public` schema of the `database`.
-   `pg_catalog` schema: Contains the system tables and all the built-in data types, functions, and operators. `pg_catalog` is always effectively and implicitly part of the `search path`.


### Related access control notes {#related-access-control-notes}


#### `PUBLIC` role / keyword {#public-role-keyword}

-   It's not exactly a `role` but a keyword that can be a placeholder for `role`
-   This keyword usually means "everyone"
-   This is different from `public` schema. eg. `REVOKE CREATE ON SCHEMA public FROM PUBLIC;` (first “public” is the schema, the second “public” means “every user”)
-   It used to gives create permission on the `public schema` to "all" users despite what grant is at play.
    -   `USAGE` privilege granted to `PUBLIC`: Allows anyone to refer to objects in the public schema.
    -   `CREATE` privilege granted to `PUBLIC`: Allows anyone to create objects in the public schema.
        -   This is problematic!
-   Postgrs14 onwards there is a fix for this issue
    -   new role `pg_database_owner`, implicitly has the actual owner of the current database as a member.
    -   public schema is owned by `pg_database_owner` now.
    -   public schema does not have `CREATE` privileges anymore.


## Postgres Syntax notes {#postgres-syntax-notes}


### JSONB {#jsonb}

-   Prefer jsonb over json if possible


#### Operators &amp; Functions {#operators-and-functions}

-   Checks
    -   exists: `?` , `?|` (any), `?&` (all)
        -   eg. `SELECT '["foo", "bar", "baz"]'::jsonb ? 'bar';`
        -   Not nested
        -   works with array items
        -   works only with keys when items in array are objects
    -   containment
        -   `<@`
            -   Can operate on nested elements
            -   Eg. `SELECT doc->'site_name' FROM websites WHERE doc @> '{"tags":[{"term":"paris"}, {"term":"food"}]}';`
        -   `@>`
-   Access
    -   subscripting `[x]` (Extract &amp; Modify jsonb)
        -   Result of subscript always a `jsonb`
        -   Array indexes start at 0, -ve indexes supported
        -   Can access nested element by successive subscripting
    -   `->`
        -   Array(index) and object(key) access
    -   `->>`
        -   Array(index) and object(key) access `as text`
    -   `#>` (path)
        -   Array(index) and object(key) access
    -   `#>>` (path)
        -   Array(index) and object(key) access `as text`
-   Manipulation
    -   `||` : concat objects
    -   `-` : subtract keys


#### Updating jsonb values {#updating-jsonb-values}

> It's important to note that in each of these examples, you're not actually updating a single field of the JSON data. Instead, you're creating a temporary, modified version of the data, and assigning that modified version back to the column. In practice, the result should be the same, but keeping this in mind should make complex updates, like the last example, more understandable. [SO answer](https://stackoverflow.com/questions/26703476/how-to-perform-update-operations-on-columns-of-type-jsonb)

-   Ways to do it
    -   `UPDATE` &amp; `SET`
        -   `UPDATE` &amp; `SET` combined will work with subscripts
            -   Eg. `UPDATE table_name SET jsonb_column_name['a']['b']['c'] = '1';`
            -   This will create nested parent element if they don't exist
            -   Unlike(?) `jsonb_set`, it'll try to fill things with null, and consider null column as `{}` etc.
        -   When using this, we can also use `||` for "merge" like operation, this is useful when doing ON CONFLICT UPDATE for jsonb. [See](https://dba.stackexchange.com/questions/295298/how-to-update-a-property-value-of-a-jsonb-field) [How can I merge an existing jsonb field when upserting a record in Postgres?](https://stackoverflow.com/questions/44395760/how-can-i-merge-an-existing-jsonb-field-when-upserting-a-record-in-postgres)
            -   But this merge is only shallow, [doesn't work with nested JSON](https://stackoverflow.com/questions/57927605/updating-jsonb-field-using-concatenation-operator-in-postgres).
        -   For nested JSON check these:
            -   [json - Merging JSONB values in PostgreSQL? - Stack Overflow](https://stackoverflow.com/questions/42944888/merging-jsonb-values-in-postgresql/42954907#42954907)  (Vanilla PG, has nice answers)
            -   Use a separate Procedural Language add-on [like PLV8](https://www.reddit.com/r/PostgreSQL/comments/wqx43z/should_one_use_plpgsql_or_another_variant_to/)
                -   <https://gist.github.com/phillip-haydon/54871b746201793990a18717af8d70dc> (function using plv8)
    -   `jsonb_set`
        -   Returns target with the item designated by `path` replaced by new_value, or with new_value added.
        -   Useful when you know the structure of the json.
        -   It can also do merging if you specify the path. But not much useful when you're unaware of the structure.


#### Indexes on jsonb {#indexes-on-jsonb}

-   To use indexes(GIN), we need to apply the operator on the entire column of jsonb type, picking on specific field would not make use of the index if using `simple index`, otherwise we can use `expression index` for specific field in the json document.
-   Supported operators: `?`, `?|`, `?&`, `@>`, jsonpath operators `@?`, `@@`

<!--list-separator-->

-  Types

    -   `jsonb_path_ops`
        -   Seems to have some advantage over `jsonb_ops` that I don't care about at the moment
    -   `jsonb_ops`
        -   simple &amp; expression

<!--list-separator-->

-  Expression indexes vs Simple indexes (jsonb_ops)

    -   Simple index
        -   Eg. `CREATE INDEX idxgin ON api USING GIN (jdoc);`
        -   Will store copies of every key and value in the jdoc column
        -   More flexible, supports any key but bigger in size and might be slower
    -   Expression index
        -   Eg. `CREATE INDEX idxgintags ON api USING GIN ((jdoc -> 'tags'));`
        -   Stores only data found under the `tags` key in the example


## Management/Admin {#management-admin}

See [Operations cheat sheet - PostgreSQL wiki](https://wiki.postgresql.org/wiki/Operations_cheat_sheet)
![](/ox-hugo/20221102123302-postgresql-282793601.png)
![](/ox-hugo/20221102123302-postgresql-1713348057.png)


### Postmaster &amp; Backend workers &amp; Backend processes {#postmaster-and-backend-workers-and-backend-processes}

-   `postmaster` is the primary daemon process for a PostgreSQL server.
-   The use of term is not done these days, the primary daemon process is simply being called `postgres` now.
-   Responsibilities
    -   Initializes the database system, prepares it for incoming connections, and ensures that the system is in a consistent state.
    -   Manages connections (spun off processes/ `backends processes`)
    -   [Logging]({{< relref "20221101183142-logging.md" >}})
-   `Backens processes`
    -   Config: `max_connections`
    -   Backend processes communicate with each other and with other processes of the instance using
    -   semaphores and shared memory to ensure data integrity throughout concurrent data access.
    -   i.e `connection` = `backend process` = `session` (unless using `pools`)
-   `Background workers`
    -   Config: `max_worker_processes`
    -   The `backend processes` spin up the `background workers` for actual work if parallel is enabled.
    -   This is different from `background writer` which is a Auxilary process.


### Shared Memory {#shared-memory}

-   As we read things from the disk etc. we put things in memory
-   Everything that is shared, it lives here. Pages, WAL records etc.
-   Every `backend process` and `backend worker` and everything else has access to it.
-   Related terms: `shared_buffers`, buffer pools
-   Provisioned by [mmap]({{< relref "20230405022848-mmap.md" >}}) (?)


### Auxiliary Processes {#auxiliary-processes}

{{< figure src="/ox-hugo/20221102123302-postgresql-746130329.png" >}}

-   `background writer` : It writes the dirty pages to the OS periodically. So it frees up shared memory in the `postgres` process but doesn't ensure that shit actually got to disk, that's upto the os whether it keeps it in the fs chache or what etc.
-   `checkpointer`: Flushes pages+wal to disk. Ensure that things have reached the disk.
-   `Autovacuum Launcher`
    -   config: `autovacuum_max_workers`
    -   It launches `autovacuum` workers
-   `wal`
    -   `archiver`: Archives everything for the wal (can be used for replay)
    -   `reciever`: Runs where we want to receive the WAL changes.
    -   `senders`: Senders of the WALs to replicas
    -   `writer`: Writing the WAL records from shared memory to disk. Controlled by `wal_writer_delay`
-   `starter`
    -   This combines `checkpointer` and `wal` for REDO(roll-forward recovery).
    -   Doesn't let any incoming connection till it ensures that it loaded the wal into the shared memory and made that data dirty before the `checkpoint`
    -   Now you're back in the same point before the crash happened.


### Cluster {#cluster}


#### What it's NOT {#what-it-s-not}

-   It is NOT what we popularly understand as cluster(compute cluster). This tripped me up for years man.
    -   If you were do that, you'll end up creating cluster of postgres clusters. (This is basically bad naming for historic reasons)
-   It's unrelated to the keyword `CLUSTER` which allows you to [organize a table](https://www.postgresql.org/docs/current/sql-cluster.html).


#### What it is {#what-it-is}

-   A `postmaster` / primary postgres process and a group of subsiduary processes
-   These processes manage a shared data directory that contains one or more databases.
-   It's created for you when you do `initdb`
-   Unusual for a basic or intermediate user to ever need to create clusters or manage multiple clusters as one cluster can manage multiple DBs
-   Having multiple cluster means having &gt;1 `postmaster` / primary `postgres` processes running on different ports. This is usually not needed.
-   See [PostgreSQL: Documentation: 16: 19.2. Creating a Database Cluster](https://www.postgresql.org/docs/current/creating-cluster.html)


### Replication {#replication}

See [Data Replication]({{< relref "20231021151742-data_replication.md" >}})


### System Metadata {#system-metadata}


#### System Catalogs {#system-catalogs}


#### System Views {#system-views}


### Users and Roles {#users-and-roles}

-   ALTER: Modify a role for its attributes
-   GRANT/REMOVE: Groups/Memberships leading to inheritance of privilege


#### Roles {#roles}

-   `select * from pg_roles;` same as `\du`
-   PostgreSQL manages database access permissions using the concept of `roles`
-   They have nothing to do with OS user.
-   `ROLE` = user / group of users. (Any role can act as a user, a group, or both)
-   Some attributes: SUPERUSER,CREATEDB,CREATEROLE,INHERIT,LOGIN,REPLICATION,BYPASSRLS (from the `CREATE ROLE` command)
-   Can own
    -   `databases`
    -   `objects` in that `database`
-   Can have
    -   `privileges` on `objects`
-   Can give/grant
    -   `access` to other `role` (s) on the owned `objects`
    -   `membership` in its `role` to another `role` (once two roles share `membership`, they can share `privileges`)

<!--list-separator-->

-  Predefined roles

    -   Predefined roles were introduced in pg14.
    -   Useful for things like granting readonly access etc.

<!--list-separator-->

-  "postgres" role

    -   The default `postgres` role doesn’t have an “empty password”, it literally has no password which means one cannot connect using a password-based method.


#### Privileges {#privileges}

-   `objects` can require certain `privilege` to be accessed.
-   This `privilege` can be granted to `roles`
    -   Indirectly: from `other roles`
    -   Directly: to `objects`
    -   See GRANT for more info.

<!--list-separator-->

-  Inheritance

    -   Whether the `privileges` of the granted `role` should be “inherited” by the new member.
    -   NOTE: It does not apply to the special role attributes set by CREATE ROLE and ALTER ROLE.
        -   Eg. Being a member of a role with CREATEDB privilege does not immediately grant the ability to create databases, even if INHERIT attribute is set
    -   Controlled in 2 places
        -   Role level: Role can have the `INHERIT` attribute to inherit.
        -   Command level: `GRANT` has `WITH INHERIT` to explicitly inherit.

<!--list-separator-->

-  ALTER

    -   Assigned attributes to a `ROLE` can be modified with `ALTER ROLE`
    -   `ALTER DEFAULT PRIVILEGES` allows you to set the privileges that will be applied to objects created in the future. (It does not affect privileges assigned to already-existing objects.)


#### GRANT / REVOKE {#grant-revoke}

-   Used for mutating `memberships` and privilege to objects
-   GRANT and REVOKE can also be done by a `role` that is not the owner of the affected object
    -   If it is a member of the role that owns the object
    -   If it is a member of a role that holds privileges `WITH GRANT OPTION` on the `object`.
-   Can be GRANT'ed on 2 things
    -   `objects`
        -   GRANT INSERT ON films TO PUBLIC;
        -   GRANT ALL PRIVILEGES ON kinds TO manuel;
        -   One of: SELECT,INSERT ,UPDATE ,DELETE ,TRUNCATE ,REFERENCES ,TRIGGER ,CREATE ,CONNECT ,TEMPORARY ,EXECUTE ,USAGE ,SET ,ALTER SYSTEM and `ALL PRIVILEGES`
    -   `roles`
        -   Eg. Grant membership in role `coolbois` to user `joe`: `GRANT admins TO joe;`


#### Links {#links}

-   [Application users vs. Row Level Security - 2ndQuadrant | PostgreSQL](https://www.2ndquadrant.com/en/blog/application-users-vs-row-level-security/)
-   [PostgreSQL: Documentation: 8.1: Database Roles and Privileges](https://www.postgresql.org/docs/8.1/user-manag.html)
-   [PostgreSQL: Documentation: 8.1: Role Attributes](https://www.postgresql.org/docs/8.1/role-attributes.html)


### Vertically Scaling Postgres (Finetuning with [ZFS]({{< relref "20230623091743-zfs.md" >}})) {#vertically-scaling-postgres--finetuning-with-zfs-20230623091743-zfs-dot-md}

![](/ox-hugo/20221102123302-postgresql-460901966.png)
See [Scaling Databases]({{< relref "20230608143206-scaling_databases.md" >}})

-   <https://people.freebsd.org/%7Eseanc/postgresql/scale15x-2017-postgresql_zfs_best_practices.pdf>
-   [Everything I've seen on optimizing Postgres on ZFS](https://vadosware.io/post/everything-ive-seen-on-optimizing-postgres-on-zfs-on-linux/)
-   Templates/References
    -   <https://github.com/CrunchyData/postgres-operator>
    -   <https://github.com/supabase/postgres>
    -   <https://github.com/zalando/postgres-operator?tab=readme-ov-file>


### [TLS]({{< relref "20230210181907-tls.md" >}})/SSL for postgres {#tls--20230210181907-tls-dot-md--ssl-for-postgres}

-   TLS/SSL in a trusted network is not really necessary for postgres
-   But you still would want to have SCRAM even in trusted networks


## Features {#features}


### Temporary Tables {#temporary-tables}

-   Implemented like regular tables, but uses `temp_buffers` and uses disk for storing metadata and overflows etc.
-   Unlike regular tables, not guaranteed to be used by multiple connections at the same time, are not subject to locks, are not written to WAL, etc.
-   Located in PostgreSQL system tables. In addition, for each table, one or more files are created on disk (by default, in the same folder as the files for regular tables).
-   Allows different sessions to use the same temporary table name for different purposes
-   Automatically dropped at the end of a session, or optionally at the end of the current transaction based on `ON COMMIT`


#### Issues {#issues}

-   Autovacuum daemon cannot access and therefore cannot vacuum or analyze temporary tables.
-   Need to be purged
    -   `DELETE ALL` bad cuz MVCC is used for Temporary tables aswell and deleting records is slow  (See [Concurrency]({{< relref "20221126204257-concurrency.md" >}}))
    -   So we `TRUNCATE`: `TRUNCATE` simply creates a new file on disk and does an UPDATE of the `pg_class` table.


#### Read more {#read-more}

-   [PostgreSQL and Temporary Tables - DEV Community](https://dev.to/crushby/postgresql-and-temporary-tables-1ned)


### UPSERT {#upsert}

```sql
-- canonical
INSERT INTO table (col1, col2, col3)
VALUES (val1, val2, val3)
ON
 CONFLICT conflict_target conflict_action;
-- example
INSERT INTO employees (id, name, email)
VALUES (2, ‘Dennis’, ‘dennisp@weyland.corp’)
ON CONFLICT (id) DO UPDATE;
-- conflict_target: (id)
-- conflict_action: DO UPDATE
```


### Granular Access Control {#granular-access-control}


#### Row Level Security (RLS) {#row-level-security--rls}

-   **It needs to be enabled on per-table basis**
-   Access control is fully modeled inside the database
-   It doesn't matter as who you connect to it anymore
-   As long as your request can be appropriately authenticated into a database role for that row in the table you're good.
-   Row security policies can be specific to commands, or to roles, or to both.


### Nested/Sub Transactions {#nested-sub-transactions}

```sql
BEGIN; -- Start the main transaction
-- Perform some operations
INSERT INTO accounts (account_id, amount) VALUES (1, 1000);
-- Create a savepoint
SAVEPOINT my_savepoint;
-- Perform operations within the nested transaction
INSERT INTO transactions (trans_id, account_id, amount) VALUES (101, 1, 100);
UPDATE accounts SET amount = amount - 100 WHERE account_id = 1;
-- Decide to roll back the nested transaction
ROLLBACK TO SAVEPOINT my_savepoint;
-- The nested transaction's changes are undone, but the main transaction is still in progress
-- Continue with other operations
INSERT INTO logs (message) VALUES ('Nested transaction was rolled back.');
-- Finally, commit the main transaction
COMMIT;
```

-   See [Database Transactions]({{< relref "20231113145513-database_transactions.md" >}})
-   We want to avoid such nested transactions if possible.
-   Let the application logic create the transaction and put things in. If possible don't try to handle this at the DB level.
-   Subtransactions can commit or abort without affecting their parent transactions, allowing parent transactions to continue.
-   Started using `SAVEPOINT` / `EXECEPTION`


### WAL {#wal}

-   Main idea: Changes to data files (where tables and indexes reside) must be written only after those changes have been logged
-   With the WAL, we will be able to recover the database so we need not flush pages on every transaction
-   When restoring the WAL after a crash, we'll recover to the `checkpoint` created by the `checkpointer`


#### Synchronous v/s Async commit {#synchronous-v-s-async-commit}

-   It is possible to have both synchronous and asynchronous commit transactions running concurrently
-   Certain transactions are always synchronous, eg. DROP TABLE, [Two Phase Commit (2PC)]({{< relref "20231116010456-two_phase_locking_2pl.md" >}}) prepared transaction etc.

<!--list-separator-->

-  Synchronous

    Usually commits are synchronous, i.e if there's a commit, there'll be a WAL flush, and the commit is successful only if the flush was successful. (This is the default)

<!--list-separator-->

-  Asynchronous

    -   [PostgreSQL]({{< relref "20221102123302-postgresql.md" >}}) allows you to do asynchronous commits aswell.
    -   This introduces the risk of data loss. (not data corruption)
    -   Should not be used if the client will take external actions relying on the assumption that the transaction will be remembered.
    -   But for things like [Event]({{< relref "20230406185222-event_sourcing.md" >}}) [Logging]({{< relref "20221101183142-logging.md" >}}), maybe this would be fine


#### WAL flush v/s Data flush {#wal-flush-v-s-data-flush}

-   The WAL file is written sequentially, and so the cost of syncing the WAL is much less than the cost of flushing the data pages.
-   If DB is handling many small concurrent transactions, one fsync of the WAL file may suffice to commit many transactions. `commit_delay` can be used to increase the window of transactions to be flushed.


#### Journaling filesystems {#journaling-filesystems}

-   In certain cases if the underlying [Filesystem]({{< relref "20221101145053-filesystems.md" >}}) (the [sqlite]({{< relref "20230702184501-sqlite.md" >}}) VFS interface)  there's journaling support, in those cases we can probably not use sqlite journaling and gain some performance gains but this is not needed usually and unnecessarily complex. This can also be vice versa, we can disable filesystem journaling too.


### MVCC Implementation {#mvcc-implementation}

See [MVCC]({{< relref "20231116004530-mvcc.md" >}})


### VACUUM {#vacuum}

See [A Detailed Understanding of MVCC and Autovacuum Internals in PostgreSQL 14](https://www.youtube.com/watch?v=meU2qKRzkCM)


#### Terms {#terms}

-   Live Tuples : Tuples that are Inserted or up-to-date or can be read or modified.
-   Dead Tuples : Tuples that are changed (Updated/Deleted) and unavailable to be used for any future transactions. (This is what Vaccum clears)


#### Usecase {#usecase}

<!--list-separator-->

-  MVCC Version Cleanup

    -   VACUUM is like a [Garbage collector]({{< relref "20221101213015-garbage_collection.md" >}}) for older versions of rows created by [MVCC]({{< relref "20231116004530-mvcc.md" >}})
    -   `transaction id` is a `32-bit integer`
        -   the `VACUUM` process is responsible for making sure that the id does not overflow.
        -   Never disable the VACUUM, else transaction wraparound
    -   See [Database Transactions]({{< relref "20231113145513-database_transactions.md" >}})

<!--list-separator-->

-  Run ANALYZE on tables


#### Freezing {#freezing}

{{< figure src="/ox-hugo/20221102123302-postgresql-489278158.png" >}}


#### autovaccum conditions {#autovaccum-conditions}

{{< figure src="/ox-hugo/20221102123302-postgresql-1284047124.png" >}}


## Internals {#internals}


### Pages {#pages}

-   AKA Data blocks
-   Page number starts from 0


## Major updates and Replication {#major-updates-and-replication}


### Major Upgrades {#major-upgrades}

-   [Zero downtime Postgres upgrades | Hacker News](https://news.ycombinator.com/item?id=38616181)


## Other extra info on Postgres {#other-extra-info-on-postgres}


### Psycogpg2 notes {#psycogpg2-notes}


#### Core Concepts {#core-concepts}

> Connection &gt; Transaction (each `with conn` block) &gt; Cursor

<!--list-separator-->

-  Connection

    -   Encapsulates a database session
    -   [Thread Safe]({{< relref "20221101173032-threads.md#thread-safety" >}}) and can be shared among many threads.
    -   closing a connection without committing the changes first will cause any pending change to be discarded

<!--list-separator-->

-  Transactions

    -   transactions are handled by the `connection` class
        -   The `connection` is responsible for terminating its transaction, calling either the `commit() or rollback()`
        -   If `close()` is called or something goes wrong in middle of a transaction its dropped by the db servr
    -   `autocommit` mode
        -   `connection` can be set to autocommit mode
        -   no rollback possible
        -   All the commands executed will be immediately committed
    -   Transactions are per-session, i.e. per-connection.

<!--list-separator-->

-  Cursor

    -   Not thread safe

    <!--list-separator-->

    -  Client side cursor

        -   Allows Python code to execute PostgreSQL command in a database session(`connection` -&gt; `transaction`)
        -   Bound to a connection for the entire lifetime

    <!--list-separator-->

    -  Server side cursor

        -   When creating a cursor, if a name is specified, it'll be a server side cursor
        -   By default a named cursor is declared without `SCROLL` and `WITHOUT HOLD`


#### Context manager (with) {#context-manager--with}

|              | after `with` exit, it is closed? | after `with` exit, transaction is committed?            |
|--------------|----------------------------------|---------------------------------------------------------|
| `connection` | NO                               | YES, if no exception. (i.e `transaction` is terminated) |
| `cursor`     | YES, any resources is released   | NO, no notion of transaction here.                      |

-   `with` can be used with both `connection` and `cursor`. So the `with` exit action only applies if its used to it. Eg. Having a `connection` but only using `with` with the `cursor` will **NOT** close the `connection`.
    -   In a way using `with` for `connection` is more conceptually along the lines of using context manager for the `transaction`
-   A `connection` can be used in more than a `with` statement (i.e more than one context)
    -   Each with block is effectively wrapped in a separate `transaction`
-   Since context manager will not handle `connection.close()` for you, if you don't want a long running database session. Make sure to call it wherever it seems fit.


#### FAQ {#faq}

-   In the docs there are mentions of `command`, it simply means sql query. got me confused.

<!--list-separator-->

-  Do we need to commit SELECT(s)?

    -   SELECT is a transaction
    -   But you can get by without committing it, but always good to commit it (context managers will do it for you)

<!--list-separator-->

-  .commit() vs SQL COMMIT

    -   See [python - Postgres: cursor.execute("COMMIT") vs. connection.commit() - Stack Overflow](https://stackoverflow.com/questions/23496497/postgres-cursor-executecommit-vs-connection-commit)
    -   TLDR prefer whatever the api provides unless you have other reasons

<!--list-separator-->

-  On closing Transaction and Connections

    -   <https://github.com/psycopg/psycopg2/issues/1044>
    -   leaving a transaction open is a worse outcome than keeping a connection open
    -   "I prefer to have 300 leaking connections open than 3 transactions forgot open on a busy server."
    -   [Is it required to close a Psycopg2 connection at the end of a script?](https://stackoverflow.com/questions/31240830/is-it-required-to-close-a-psycopg2-connection-at-the-end-of-a-script)
        -   It's good practice to as soon as you don't need the connection
        -   Not closing the connection might have weird errors on logs pg side

<!--list-separator-->

-  Long running connections

    -   The difficulty with long-lived connections is that you might not be entirely sure that they're still there.
        -   Generally try to close the connection asap if possible
    -   If using something like a webserver, re-creation of connection can be expecisive. This is when you'd want to use connection pools, server or client side based on the architecture of your application


#### To read (TODO) {#to-read--todo}

-   <https://www.psycopg.org/docs/usage.html>
-   <https://www.psycopg.org/docs/advanced.html#connection-and-cursor-factories>
-   <https://www.psycopg.org/docs/faq.html>
-   <https://discuss.python.org/t/stuck-with-psycopg2-multithreading/39918/3>
-   <https://www.timescale.com/blog/when-and-how-to-use-psycopg2/>


### Relevant Notes {#relevant-notes}

-   **Initializing a postgres directory:** After logging into the `postgres` user, you can create a directory with necessary postgres files with the `initdb` command. It creates a directory in the file system and then you can start a postgres server directing it to that directory.
-   **Tablespaces:** All tables are by default created in `pg_default` tablespace, creating in a tablespace does not affect the logical SQL schema.


### Tools {#tools}


#### Routing {#routing}

-   <https://github.com/pgbouncer/pgbouncer>
-   [Prepared Statements in Transaction Mode for PgBouncer](https://www.crunchydata.com/blog/prepared-statements-in-transaction-mode-for-pgbouncer#how-much-faster-are-prepared-statements)


#### Others {#others}

-   [Ways to capture changes in Postgres | Hacker News](https://news.ycombinator.com/item?id=37610899)
-   <https://github.com/zalando/patroni>
-   <https://github.com/pganalyze/libpg_query>
-   <https://github.com/wal-g/wal-g>
-   <https://github.com/pgbackrest/pgbackrest>
-   <https://github.com/cybertec-postgresql/pgwatch2>
-   <https://github.com/citusdata/pg_cron>
-   <https://github.com/cybertec-postgresql/pg_timetable>


#### Extension {#extension}

-   [Postgres Extensions Overview | Supabase Docs](https://supabase.com/docs/guides/database/extensions)
-   [Pg_jsonschema – JSON Schema Support for Postgres | Hacker News](https://news.ycombinator.com/item?id=35258323)
-   [pgvector: Embeddings and vector similarity | Supabase Docs](https://supabase.com/docs/guides/database/extensions/pgvector)


#### Ecosystem {#ecosystem}

-   psql: [Psql Tips | Hacker News](https://news.ycombinator.com/item?id=34909670) | <https://github.com/okbob/pspg>
-   pgcli: CLI for Postgres with auto-completion and syntax highlighting. (Can be used instead of psql)
-   [gunnarmorling/pgoutput-cli](https://github.com/gunnarmorling/pgoutput-cli): Examining the output of logical replication slots using pgoutput encoding
-   <https://github.com/dalibo/pg_activity> : htop for pg
-   <https://gitlab.com/dmfay/pdot>


### Links {#links}

-   [Types of Indexes in PostgreSQL](https://www.highgo.ca/2020/06/22/types-of-indexes-in-postgresql/)
-   <https://twitter.com/samokhvalov/status/1713094683159941508>
-   <https://twitter.com/samokhvalov/status/1713094683159941508>
-   <https://twitter.com/samokhvalov/status/1702812327261950130>
-   [Explain Guide](https://www.pgmustard.com/docs/explain)
-   <https://github.com/allaboutapps/integresql>
-   [Five Tips For a Healthier Postgres Database in the New Year](https://www.crunchydata.com/blog/five-tips-for-a-healthier-postgres-database-in-the-new-year)
-   [Making PostgreSQL tick: New features in pg_cron | Hacker News](https://news.ycombinator.com/item?id=38029671)
-   [Show HN: Light implementation of Event Sourcing using PostgreSQL as event store | Hacker News](https://news.ycombinator.com/item?id=38084098)
-   <https://blog.peerdb.io/real-time-change-data-capture-from-postgres-16-read-replicas>
-   [Postgres WAL Files and Sequence Numbers](https://www.crunchydata.com/blog/postgres-wal-files-and-sequuence-numbers)
-   [Operating on a minimal two-core Postgres instance: Query optimization insight...](https://news.ycombinator.com/item?id=38276727)
-   [An automatic indexing system for Postgres | Hacker News](https://news.ycombinator.com/item?id=38300297)
-   [Postgres schema changes are still a PITA | Lobsters](https://lobste.rs/s/ze70h7/postgres_schema_changes_are_still_pita)


#### Other comments {#other-comments}

<!--list-separator-->

-  tw1

    Some PostgreSQL footguns:

    -   default configuration
    -   long transactions mixed with OLTP workload
    -   repmgr (and other HA tools not based on consensus algorithms)
    -   LISTEN/NOTIFY
    -   "pg_dump is a utility for backing up a PostgreSQL database" says the official doc
    -   moving/copying PGDATA and ignoring glibc version change
    -   hot_standby_feedback on/off dilemma
    -   partitioning of tables having high number of indexes and receiving QPS &gt;&gt; 1k
    -   "setting statement_timeout in postgresql.conf is not recommended because it would affect all sessions" says the official doc
    -   using replication slots w/o setting max_slot_wal_keep_size
    -   relying only on statement_timeout &amp; idle_in_transaction_session_timeout and thinking it's enough (lack of transaction_timeout)
    -   data types "money", "enum", "timestamp" (3 different cases)
    -   int4 PK
    -   massive DELETE
    -   attempts to use transactional version of DDL (e.g., CREATE INDEX) under heavy loads
    -   subtransactions
    -   DDL under load without lock_timeout
